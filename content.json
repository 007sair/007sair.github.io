{"meta":{"title":"FE blog","subtitle":"记录前端的点点滴滴","description":"simple technology, simple life","author":"@chan","url":"http://007sair.github.io"},"pages":[{"title":"about","date":"2017-08-25T07:03:37.000Z","updated":"2018-07-26T07:08:26.521Z","comments":true,"path":"about/index.html","permalink":"http://007sair.github.io/about/index.html","excerpt":"","text":"GitHub：007sair Mail：163"},{"title":"categories","date":"2018-01-12T06:23:01.000Z","updated":"2018-07-26T07:08:26.521Z","comments":true,"path":"categories/index.html","permalink":"http://007sair.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-12T07:20:05.000Z","updated":"2018-07-26T07:08:26.555Z","comments":true,"path":"tags/index.html","permalink":"http://007sair.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Date对象在ios中的坑","slug":"Date对象在ios中的坑","date":"2018-10-18T01:23:26.000Z","updated":"2018-10-18T01:27:56.025Z","comments":true,"path":"2018/10/18/Date对象在ios中的坑/","link":"","permalink":"http://007sair.github.io/2018/10/18/Date对象在ios中的坑/","excerpt":"","text":"平时需要对日期进行操作时，服务端都会返回这样的日期格式 123&#123; start_time: \"2017-08-11 12:00:00\"&#125; 当我们把这种格式放入Date对象中时，在ios的safari中会出现错误，返回valid Date 最后得出原因：ios中不支持-连接的日期 所以，我们需要将日期替换成/连接方式，如下： 1\"2017-08-11 12:00:00\".replace(/-/g, \"/\") // =&gt; \"2017/08/11 12:00:00\"","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"移动端File和Base64的坑","slug":"移动端File和Base64的坑","date":"2018-08-29T06:16:50.000Z","updated":"2018-08-29T09:09:23.862Z","comments":true,"path":"2018/08/29/移动端File和Base64的坑/","link":"","permalink":"http://007sair.github.io/2018/08/29/移动端File和Base64的坑/","excerpt":"最近在做移动端的图片操作项目，会涉及到上传图片、Canvas、转换base64等操作，被坑得不能自理，不过好在都解决了~ 记录如下： 一、TypeError: FileConstructor is not a constructor背景这个错误是我在微信浏览器中点击上传图片按钮时发生的，具体逻辑为依次调用微信JSSDK中的wx.chooseImage和wx.getLocalImgData，第二个接口会返回base64数据。 此时我们需要将base64转换为File对象，再通过FormData传给服务端来处理其他业务。所以我预先写了一个dataURL2file函数，如下： 1234567891011121314151617/** * 将base64转换为file对象 * @param &#123;string&#125; dataURL base64数据 * @param &#123;string&#125; filename 文件名 */function dataURL2file(dataURL, filename = 'custom_file') &#123; var arr = dataURL.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; filename += '.' + mime.split('/')[1] return new File([u8arr], filename, &#123; type: mime &#125;);&#125;","text":"最近在做移动端的图片操作项目，会涉及到上传图片、Canvas、转换base64等操作，被坑得不能自理，不过好在都解决了~ 记录如下： 一、TypeError: FileConstructor is not a constructor背景这个错误是我在微信浏览器中点击上传图片按钮时发生的，具体逻辑为依次调用微信JSSDK中的wx.chooseImage和wx.getLocalImgData，第二个接口会返回base64数据。 此时我们需要将base64转换为File对象，再通过FormData传给服务端来处理其他业务。所以我预先写了一个dataURL2file函数，如下： 1234567891011121314151617/** * 将base64转换为file对象 * @param &#123;string&#125; dataURL base64数据 * @param &#123;string&#125; filename 文件名 */function dataURL2file(dataURL, filename = 'custom_file') &#123; var arr = dataURL.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; filename += '.' + mime.split('/')[1] return new File([u8arr], filename, &#123; type: mime &#125;);&#125; 上述代码在部分手机中直接报错： 123// Reference to: new File()TypeError: FileConstructor is not a constructor (evaluating 'new File') 原因是部分手机系统版本还不支持File，ios低于9.3(含)、安卓低于4.4(含)都不支持，见：caniuse 解决方法将Base64转换为Blob对象，blob的兼容性相对File会更好一些，参考caniuse 1234567891011121314151617181920212223242526272829303132/** * dataURL 转成 blob * @param dataURL * @return blob */function dataURL2blob(dataURL) &#123; let binaryString = atob(dataURL.split(',')[1]); let arrayBuffer = new ArrayBuffer(binaryString.length); let intArray = new Uint8Array(arrayBuffer); let mime = dataURL.split(',')[0].match(/:(.*?);/)[1] for (let i = 0, j = binaryString.length; i &lt; j; i++) &#123; intArray[i] = binaryString.charCodeAt(i); &#125; let data = [intArray]; let result; try &#123; result = new Blob(data, &#123; type: mime &#125;); &#125; catch (error) &#123; window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder; if (error.name === 'TypeError' &amp;&amp; window.BlobBuilder) &#123; var builder = new BlobBuilder(); builder.append(arrayBuffer); result = builder.getBlob(type); &#125; else &#123; throw new Error('没救了'); &#125; &#125; return result;&#125; 当然，放不下dataURL2file这个函数，我们也可以做兼容处理： 12345678910111213141516171819function dataURL2file(dataURL, filename = 'custom_file') &#123; try &#123; var arr = dataURL.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; filename += '.' + mime.split('/')[1] return new File([u8arr], filename, &#123; type: mime &#125;); &#125; catch (error) &#123; console.warn('Browser does not support the File constructor,Will use blob instead of file') return dataURL2blob(dataURL) &#125;&#125; 二、使用img.onload事件加载base64图片时，触发了onerror背景有时我们需要将本地的base64绘制到canvas中，如果直接调用canvas的drawImage方法，可能图片还没加载就触发了绘制，从而导致绘制失败。所以，我们需要保证图片已经加载完成再触发绘制： 1234567let canvas = document.createElement('canvas')let ctx = canvas.getContext('2d')var img = new Image()img.onload = function() &#123; ctx.drawImage(img, 0, 0);&#125;img.src = 'data:image/png;base64,iVBORw0KGgoAAAANS...' 以上代码只在ios v10.3以下的版本会触发onerror错误，安卓尚未发现问题。 翻越各种文档都没有相关资料，只找到一个类似的问题：ie10-base64-encoded-image-load-error 猜测是base64的长度限制，导致加载失败。 解决方法既然是长度问题，有两种方案： 方案一：将base64转成file对象，让服务端返回一个http的图片链接 优点：无兼容性问题； 缺点：多一次请求，且图片加载依赖网速 方案二：将base64转成objectUrl，见：createObjectURL - MDN 12345678910111213/** * 创建新的URL 对象表示指定的 File 对象或 Blob 对象。 * @param &#123;string&#125; dataURL base64 */function dataURL2ObjUrl(dataURL) &#123; window.URL = window.URL || window.webkitURL if (window.URL &amp;&amp; URL.createObjectURL) &#123; // dataURL2blob 此方法需额外定义 var blob = dataURL2blob(dataURL) return URL.createObjectURL(blob) &#125; return dataURL&#125; 优点：无网络请求； 缺点：兼容性，PC端慎用，移动端比较完美，见：caniuse 综上述，使用objectUrl是个不错的选择~ 由于上述错误只发生在图片加载时，所以我重新封装了一下工具库的loadImage函数： 12345678910111213141516171819202122232425/** * 异步加载图片 * @param &#123;string&#125; url 图片地址 * @param &#123;boolean&#125; is_cors 是否对此元素的CORS请求设置凭据标志 * @return &#123;imageObject&#125; img对象 */function loadImage(url, is_cors = true) &#123; return new Promise((resolve, reject) =&gt; &#123; var img = new Image() if (is_cors) img.crossOrigin = 'Anonymous'; var objectURL = null if (url.match(/^data:(.*);base64,/) &amp;&amp; window.URL &amp;&amp; URL.createObjectURL) &#123; objectURL = URL.createObjectURL(this.dataURL2blob(url)) url = objectURL &#125; img.onload = () =&gt; &#123; objectURL &amp;&amp; URL.revokeObjectURL(objectURL) resolve(img) &#125; img.onerror = () =&gt; &#123; reject(new Error('That image was not found.:' + url.length)) &#125; img.src = url &#125;)&#125; 参考 File constructor is not supported in iOS Safari 8 (or 9) JavaScript 中 Blob 对象","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"H5","slug":"H5","permalink":"http://007sair.github.io/tags/H5/"}]},{"title":"本地调试微信JSSDK","slug":"本地调试微信JSSDK","date":"2018-07-26T07:21:42.000Z","updated":"2018-08-29T09:09:10.292Z","comments":true,"path":"2018/07/26/本地调试微信JSSDK/","link":"","permalink":"http://007sair.github.io/2018/07/26/本地调试微信JSSDK/","excerpt":"调试微信jssdk 最近在做一个h5的项目，需要用到微信jssdk的图片上传功能。踩坑记录~ 一、配置 进入微信公众号，找到基本配置，获取到AppID、AppSecret，后端需要使用这两个数据生成对应的tooken和tiket，此处省略。然后填写好IP白名单（重要）； 在公众号设置 - 功能设置 - JS接口安全域名 处设置需要访问页面的域名（注：有坑，见后文），如：sair.example.com。 二、调试填好配置，接下来就是调试。微信要求前端传入的url必须为动态线上的url，且端口必须为80、443，这样一来，我们在本地进行调试时就会涉及如何将本地url变成线上url的问题了。","text":"调试微信jssdk 最近在做一个h5的项目，需要用到微信jssdk的图片上传功能。踩坑记录~ 一、配置 进入微信公众号，找到基本配置，获取到AppID、AppSecret，后端需要使用这两个数据生成对应的tooken和tiket，此处省略。然后填写好IP白名单（重要）； 在公众号设置 - 功能设置 - JS接口安全域名 处设置需要访问页面的域名（注：有坑，见后文），如：sair.example.com。 二、调试填好配置，接下来就是调试。微信要求前端传入的url必须为动态线上的url，且端口必须为80、443，这样一来，我们在本地进行调试时就会涉及如何将本地url变成线上url的问题了。 本地调试环境除了电脑端的微信开发者工具，就是真机的微信环境调试。但电脑端无法调试某些接口，如chooseImage、getLocalImgData，所以，真机调试就变得尤为重要了。现将思路整理如下: 思路1，代理变更url地址前提：有Apache环境，项目能通过127.0.0.1被访问到。然后通过charles代理，使手机也能访问电脑端的域名。 工具： 一台Mac、一个iPhone； 开启代理和抓包的工具Charles； 修改Hosts工具SwitchHosts或者Gas Mask。 步骤： Mac与iPhone需在同一个局域网内； 打开charles设置代理服务； iPhone上打开设置 - 无线局域网 - 选中当前网络 - HTTP代理 - 配置代理，在服务器一栏输入Mac的ip地址，端口填写charles上的端口号（默认为8888）； 修改Mac的hosts，如：127.0.0.1 sair.example.com； 在手机上访问sair.example.com即可进行调试。 思路2，代理变更+端口转发另类场景，由于本人一直在开发环境使用webpack，本地访问地址一般都是localhost:8080，而微信仅支持80、443端口，方案如下： 提前了解：Mac禁止了普通用户访问1024以下的端口，包括80端口，因为Mac会用这些端口来提供文件共享等等很多服务。 停掉Mac自带的占用80端口的程序(其实就是一个apache)，然后再设置端口转发，将80端口的请求转发到8080或9090端口。 具体操作： 关闭占用80端口的apache：sudo apachectl stop； 修改/etc/pf.conf，设置端口转发，操作如下： 123$ sudo vi /etc/pf.conf# 在 rdr-anchor \"com.apple/*\" 后添加 rdr on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 8080 修改后的效果： 12345678910111213141516171819202122232425262728## Default PF configuration file.## This file contains the main ruleset, which gets automatically loaded# at startup. PF will not be automatically enabled, however. Instead,# each component which utilizes PF is responsible for enabling and disabling# PF via -E and -X as documented in pfctl(8). That will ensure that PF# is disabled only when the last enable reference is released.## Care must be taken to ensure that the main ruleset does not get flushed,# as the nested anchors rely on the anchor point defined here. In addition,# to the anchors loaded by this file, some system services would dynamically# insert anchors into the main ruleset. These anchors will be added only when# the system service is used and would removed on termination of the service.## See pf.conf(5) for syntax.### com.apple anchor point#scrub-anchor \"com.apple/*\"nat-anchor \"com.apple/*\"rdr-anchor \"com.apple/*\"rdr on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 9090dummynet-anchor \"com.apple/*\"anchor \"com.apple/*\"load anchor \"com.apple\" from \"/etc/pf.anchors/com.apple\" 使修改生效，依次执行以下命令： 123$ sudo pfctl -d$ sudo pfctl -f /etc/pf.conf $ sudo pfctl -e 设置hosts 1127.0.0.1 sair.example.com ok，启动webpack后，访问sair.example.com时我们实际访问的是127.0.0.1:80，而由于设置了转发，所以我们最后访问的实际是127.0.0.1:8080。 思路3，内网穿透以上两种方案均通过代理的方式实现，过程比较绕，但也能解决问题。本人在开发中遇到了http强行重定向到https的坑，所以有内网穿透这个方法：通过ngrok将内网ip映射到外网，然后手机直接访问外网地址即可~简单粗暴直接了当。 步骤： 下载Sunny-Ngrok 或者 natapp 这两个工具都适合在国内使用，对比如下： sunny-ngrok： a. 完全免费 b. 可以定义多条隧道 c. 可以完全自定义域名 d. 需要自己申请域名并备案（算是一个缺点吧） natapp： a. 基本免费，高级功能收费（如自定义域名） b. 免费版每个协议只能申请一条隧道 c. 域名随机生成，不能完全自定义域名。收费版也只能修改域名的前缀 d. 不需要单独申请域名（优点） e. 运行简单，下载执行程序直接运行即可，默认监听80端口。如果要监听其它端口，没有注册帐号的前提下，需要用web服务器做反向代理 运行软件，获取到外网映射地址直接访问 填入安全域名，分两种情况： a. 有公众平台测试账号 此时只需要填入接口配置信息的URL（后端根据此页面提供的appid，appsecret\b写好的接口\b）、约定好的token、JS接口安全域名处填写ngrok生成的外网地址。 前端调取接口获取config信息时也需要根据测试和线上环境获取不同的信息。 此方法适合使用natapp，生成的外网地址不固定，可随时更改使用。 b. 没有公众平台测试账号 我们可以在公众号设置 - 功能设置 - JS接口安全域名处填入使用sunny-ngrok生成的固定的外网域名，将验证的配置文件xxxx.txt文件放入本地服务器，保证外网地址/xxx.txt能被访问到即可。 推荐使用a方法，稳定，但需要最开始做一些配置。 参考 微信JS-SDK说明文档 解决Mac 80端口被占用 微信分享JSSDK-invalid signature签名错误的解决方案 ngrok 内网穿透，实现微信开发本地化","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"script标签中的defer和async区别","slug":"script标签中的defer和async区别","date":"2018-02-05T07:07:58.000Z","updated":"2018-07-26T07:08:26.520Z","comments":true,"path":"2018/02/05/script标签中的defer和async区别/","link":"","permalink":"http://007sair.github.io/2018/02/05/script标签中的defer和async区别/","excerpt":"script标签的位置决定了页面何时渲染，浏览器解析页面时，碰到script标签会将脚本解析完后再解析后面的html、script。 所以我们在往页面里写script标签时建议不要将script标签放在head内，而是尽量放在body之前，其他html标签之后。这样的好处是页面白屏时间会缩短，优先解析出html。","text":"script标签的位置决定了页面何时渲染，浏览器解析页面时，碰到script标签会将脚本解析完后再解析后面的html、script。 所以我们在往页面里写script标签时建议不要将script标签放在head内，而是尽量放在body之前，其他html标签之后。这样的好处是页面白屏时间会缩短，优先解析出html。 定义红宝书对这两个属性的解释如下： defer这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在&lt;script&gt;元素中设置defer属性，相当于告诉浏览器立即下载，但延迟执行。 HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在DOMContentLoad事件触发前执行，因此最好只包含一个延迟脚本。 async这个属性与defer类似，都用于改变处理脚本的行为。同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照它们的先后顺序执行。 第二个脚本文件可能会在第一个脚本文件之前执行。因此确保两者之间互不依赖非常重要。指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。 MDN上的解释如下： async，该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用 (即没有src属性的脚本）。 defer，这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发DOMContentLoaded事件前执行。如果缺少 src 属性（即内嵌脚本），该属性不应被使用，因为这种情况下它不起作用。对动态嵌入的脚本使用 async=false 来达到类似的效果。 关键点：当script标签中间有代码时，两个属性都不会起作用。 引用中这篇文章的图，描述页面加载的顺序： 绿色线代表 HTML 解析，蓝色线代表脚本网络读取，红色线代表脚本执行。 没有任何属性时，文档解析、网络读取、执行都是串行。 defer时文档解析与网络读取并行，在文档解析后，DOMContentLoaded事件触发之前执行 async则没有任何限制，文档解析时网络读取文件，读取完后立即执行。 使用时机与场景请自行琢磨~ 优先级当一个script标签内同时包含defer与async属性时，如下： 1&lt;script src=\"xxx/xxx.js\" async defer&gt;&lt;/script&gt; 此时只会触发async，不会触发defer，除非浏览器不兼容async。 兼容性 IE Chrome Firfox Safari IOS Safari Android async 10+ 8+ 3.6+ 5.1+ 5.1+ 3+ defer 10+ 8+ 3.5+ 5+ 5.1+ 3+ _*_ 以上 + 包含当前版本，如：ie10+表示含ie10","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"JavaScript开发的45个技巧","slug":"javascript开发的45个技巧","date":"2018-02-02T09:34:35.000Z","updated":"2018-07-26T07:08:26.520Z","comments":true,"path":"2018/02/02/javascript开发的45个技巧/","link":"","permalink":"http://007sair.github.io/2018/02/02/javascript开发的45个技巧/","excerpt":"JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（PhoneGap、Appcelerator）、服务器端开发（Node.js和Wakanda）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过nodebot或nodruino来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人。 在这篇文章里，我将分享一些JavaScript的技巧、秘诀和最佳实践，除了少数几个外，不管是浏览器的JavaScript引擎，还是服务器端JavaScript解释器，均适用。 本文中的示例代码，通过了在Google Chrome 30最新版（V8 3.20.17.15）上的测试。","text":"JavaScript是一个绝冠全球的编程语言，可用于Web开发、移动应用开发（PhoneGap、Appcelerator）、服务器端开发（Node.js和Wakanda）等等。JavaScript还是很多新手踏入编程世界的第一个语言。既可以用来显示浏览器中的简单提示框，也可以通过nodebot或nodruino来控制机器人。能够编写结构清晰、性能高效的JavaScript代码的开发人员，现如今已成了招聘市场最受追捧的人。 在这篇文章里，我将分享一些JavaScript的技巧、秘诀和最佳实践，除了少数几个外，不管是浏览器的JavaScript引擎，还是服务器端JavaScript解释器，均适用。 本文中的示例代码，通过了在Google Chrome 30最新版（V8 3.20.17.15）上的测试。 1、首次为变量赋值时务必使用var关键字变量没有声明而直接赋值得话，默认会作为一个新的全局变量，要尽量避免使用全局变量。 2、使用===取代====和!=操作符会在需要的情况下自动转换数据类型。但===和!==不会，它们会同时比较值和数据类型，这也使得它们要比==和!=快。 12345678[10] === 10 // is false[10] == 10 // is true'10' == 10 // is true'10' === 10 // is false [] == 0 // is true [] === 0 // is false '' == false // is true but true == \"a\" is false '' === false // is false 3、underfined、null、0、false、NaN、空字符串的逻辑结果均为false4、行尾使用分号实践中最好还是使用分号，忘了写也没事，大部分情况下JavaScript解释器都会自动添加。对于为何要使用分号，可参考文章JavaScript中关于分号的真相。 5、使用对象构造器12345function Person(firstName, lastName)&#123; this.firstName = firstName; this.lastName = lastName;&#125;var Saad = new Person(\"Saad\", \"Mousliki\"); 6、小心使用typeof、instanceof和contructor typeof：JavaScript一元操作符，用于以字符串的形式返回变量的原始类型，注意，typeof null也会返回object，大多数的对象类型（数组Array、时间Date等）也会返回object contructor：内部原型属性，可以通过代码重写 instanceof：JavaScript操作符，会在原型链中的构造器中搜索，找到则返回true，否则返回false 1234var arr = [\"a\", \"b\", \"c\"];typeof arr; // 返回 \"object\" arr instanceof Array // truearr.constructor(); //[] 7、使用自调用函数函数在创建之后直接自动执行，通常称之为自调用匿名函数（Self-Invoked Anonymous Function）或直接调用函数表达式（Immediately Invoked Function Expression ）。格式如下： 1234567(function()&#123; // 置于此处的代码将自动执行&#125;)(); (function(a,b)&#123; var result = a+b; return result;&#125;)(10,20) 8、从数组中随机获取成员12var items = [12, 548 , 'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' , 2145 , 119];var randomItem = items[Math.floor(Math.random() * items.length)]; 9、获取指定范围内的随机数这个功能在生成测试用的假数据时特别有数，比如介与指定范围内的工资数。 1var x = Math.floor(Math.random() * (max - min + 1)) + min; 10、生成从0到指定值的数字数组12var numbersArray = [] , max = 100;for( var i=1; numbersArray.push(i++) &lt; max;); // numbers = [1,2,3 ... 100] 11、生成随机的字母数字字符串12345function generateRandomAlphaNum(len) &#123; var rdmString = \"\"; for( ; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len);&#125; 12、打乱数字数组的顺序123var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];numbers = numbers.sort(function()&#123; return Math.random() - 0.5&#125;);/* numbers 数组将类似于 [120, 5, 228, -215, 400, 458, -85411, 122205] */ 这里使用了JavaScript内置的数组排序函数，更好的办法是用专门的代码来实现（如Fisher-Yates算法），可以参见StackOverFlow上的这个讨论。 13、字符串去空格Java、C#和PHP等语言都实现了专门的字符串去空格函数，但JavaScript中是没有的，可以通过下面的代码来为String对象函数一个trim函数： 123String.prototype.trim = function() &#123; return this.replace(/^\\s+|\\s+$/g, \"\");&#125;; 新的JavaScript引擎已经有了trim()的原生实现。 14、数组之间追加1234var array1 = [12 , \"foo\" , &#123;name \"Joe\"&#125; , -2458];var array2 = [\"Doe\" , 555 , 100];Array.prototype.push.apply(array1, array2);/* array1 值为 [12 , \"foo\" , &#123;name \"Joe\"&#125; , -2458 , \"Doe\" , 555 , 100] */ 15、对象转换为数组1var argArray = Array.prototype.slice.call(arguments); 16、验证是否是数字123function isNumber(n)&#123; return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);&#125; 17、验证是否是数组123function isArray(obj)&#123; return Object.prototype.toString.call(obj) === '[object Array]' ;&#125; 但如果toString()方法被重写过得话，就行不通了。也可以使用下面的方法： 1Array.isArray(obj); // its a new Array method 如果在浏览器中没有使用frame，还可以用instanceof，但如果上下文太复杂，也有可能出错。 1234567var myFrame = document.createElement('iframe');document.body.appendChild(myFrame);var myArray = window.frames[window.frames.length-1].Array;var arr = new myArray(a,b,10); // [a,b,10] // myArray 的构造器已经丢失，instanceof 的结果将不正常// 构造器是不能跨 frame 共享的arr instanceof Array; // false 18、获取数组中的最大值和最小值123var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; var maxInNumbers = Math.max.apply(Math, numbers); var minInNumbers = Math.min.apply(Math, numbers); 19、清空数组12var myArray = [12 , 222 , 1000 ]; myArray.length = 0; // myArray will be equal to []. 20、不要直接从数组中delete或remove元素如果对数组元素直接使用delete，其实并没有删除，只是将元素置为了undefined。数组元素删除应使用splice。 切忌： 12345var items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ]; items.length; // return 11 delete items[3]; // return true items.length; // return 11 /* items 结果为 [12, 548, \"a\", undefined × 1, 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119] */ 而应： 123456var items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ]; items.length; // return 11 items.splice(3,1) ; items.length; // return 10 /* items 结果为 [12, 548, \"a\", 5478, \"foo\", 8852, undefined × 1, \"Doe\", 2154, 119]删除对象的属性时可以使用delete。 21、使用length属性截断数组前面的例子中用length属性清空数组，同样还可用它来截断数组： 12var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ]; myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124]. 与此同时，如果把length属性变大，数组的长度值变会增加，会使用undefined来作为新的元素填充。length是一个可写的属性。 12myArray.length = 10; // the new array length is 10 myArray[myArray.length - 1] ; // undefined 22、在条件中使用逻辑与或123var foo = 10; foo == 10 &amp;&amp; doSomething(); // is the same thing as if (foo == 10) doSomething(); foo == 5 || doSomething(); // is the same thing as if (foo != 5) doSomething(); 逻辑或还可用来设置默认值，比如函数参数的默认值。 123function doSomething(arg1)&#123; arg1 = arg1 || 10; // arg1 will have 10 as a default value if it’s not already set&#125; 23、使得map()函数方法对数据循环1234var squares = [1,2,3,4].map(function (val) &#123; return val * val; &#125;); // squares will be equal to [1, 4, 9, 16] 24、保留指定小数位数12var num = 2.443242342;num = num.toFixed(4); // num will be equal to 2.4432 注意，toFixec()返回的是字符串，不是数字。 25、浮点计算的问题1230.1 + 0.2 === 0.3 // is false 9007199254740992 + 1 // is equal to 90071992547409929007199254740992 + 2 // is equal to 9007199254740994 为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示，具体可以参见JavaScript中的数字是如何编码的. 可以通过使用toFixed()和toPrecision()来解决这个问题。 26、通过for-in循环检查对象的属性下面这样的用法，可以防止迭代的时候进入到对象的原型属性中。 12345for (var name in object) &#123; if (object.hasOwnProperty(name)) &#123; // do something with name &#125; &#125; 27、逗号操作符1234var a = 0; var b = ( a++, 99 ); console.log(a); // a will be equal to 1 console.log(b); // b is equal to 99 28、临时存储用于计算和查询的变量在jQuery选择器中，可以临时存储整个DOM元素。 1234var navright = document.querySelector('#right'); var navleft = document.querySelector('#left'); var navup = document.querySelector('#up'); var navdown = document.querySelector('#down'); 29、提前检查传入isFinite()的参数1234567isFinite(0/0) ; // falseisFinite(\"foo\"); // falseisFinite(\"10\"); // trueisFinite(10); // trueisFinite(undefined); // falseisFinite(); // falseisFinite(null); // true，这点当特别注意 30、避免在数组中使用负数做索引123var numbersArray = [1,2,3,4,5];var from = numbersArray.indexOf(\"foo\") ; // from is equal to -1numbersArray.splice(from,2); // will return [5] 注意传给splice的索引参数不要是负数，当是负数时，会从数组结尾处删除元素。 31、用JSON来序列化与反序列化12345var person = &#123;name :'Saad', age : 26, department : &#123;ID : 15, name : \"R&amp;D\"&#125; &#125;;var stringFromPerson = JSON.stringify(person);/* stringFromPerson 结果为 \"&#123;\"name\":\"Saad\",\"age\":26,\"department\":&#123;\"ID\":15,\"name\":\"R&amp;D\"&#125;&#125;\" */var personFromString = JSON.parse(stringFromPerson);/* personFromString 的值与 person 对象相同 */ 32、不要使用eval()或者函数构造器eval()和函数构造器（Function consturctor）的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码。 12var func1 = new Function(functionCode);var func2 = eval(functionCode); 33、避免使用with()使用with()可以把变量加入到全局作用域中，因此，如果有其它的同名变量，一来容易混淆，二来值也会被覆盖。 34、不要对数组使用for-in避免： 1234var sum = 0; for (var i in arrayNumbers) &#123; sum += arrayNumbers[i]; &#125; 而是： 1234var sum = 0; for (var i = 0, len = arrayNumbers.length; i &lt; len; i++) &#123; sum += arrayNumbers[i]; &#125; 另外一个好处是，i和len两个变量是在for循环的第一个声明中，二者只会初始化一次，这要比下面这种写法快： 1for (var i = 0; i &lt; arrayNumbers.length; i++) 35、传给setInterval()和setTimeout()时使用函数而不是字符串如果传给setTimeout()和setInterval()一个字符串，他们将会用类似于eval方式进行转换，这肯定会要慢些，因此不要使用： 12setInterval('doSomethingPeriodically()', 1000); setTimeout('doSomethingAfterFiveSeconds()', 5000); 而是用： 12setInterval(doSomethingPeriodically, 1000); setTimeout(doSomethingAfterFiveSeconds, 5000); 36、使用switch/case代替一大叠的if/else当判断有超过两个分支的时候使用switch/case要更快一些，而且也更优雅，更利于代码的组织，当然，如果有超过10个分支，就不要使用switch/case了。 37、在switch/case中使用数字区间其实，switch/case中的case条件，还可以这样写： 12345678910111213141516171819function getCategory(age) &#123; var category = \"\"; switch (true) &#123; case isNaN(age): category = \"not an age\"; break; case (age &gt;= 50): category = \"Old\"; break; case (age &lt;= 20): category = \"Baby\"; break; default: category = \"Young\"; break; &#125;; return category; &#125; getCategory(5); // 将返回 \"Baby\" 38、使用对象作为对象的原型下面这样，便可以给定对象作为参数，来创建以此为原型的新对象： 123456function clone(object) &#123; function OneShotConstructor()&#123;&#125;; OneShotConstructor.prototype = object; return new OneShotConstructor(); &#125; clone(Array).prototype ; // [] 39、HTML字段转换函数123456function escapeHTML(text) &#123; var replacements= &#123;\"&lt;\": \"&lt;\", \"&gt;\": \"&gt;\",\"&amp;\": \"&amp;\", \"\\\"\": \"\"\"&#125;; return text.replace(/[&lt;&gt;&amp;\"]/g, function(character) &#123; return replacements[character]; &#125;); &#125; 40、不要在循环内部使用try-catch-finallytry-catch-finally中catch部分在执行时会将异常赋给一个变量，这个变量会被构建成一个运行时作用域内的新的变量。 切忌： 123456789var object = ['foo', 'bar'], i; for (i = 0, len = object.length; i &lt;len; i++) &#123; try &#123; // do something that throws an exception &#125; catch (e) &#123; // handle exception &#125; &#125; 而应该： 123456789var object = ['foo', 'bar'], i; try &#123; for (i = 0, len = object.length; i &lt;len; i++) &#123; // do something that throws an exception &#125; &#125; catch (e) &#123; // handle exception &#125; 41、使用XMLHttpRequests时注意设置超时XMLHttpRequests在执行时，当长时间没有响应（如出现网络问题等）时，应该中止掉连接，可以通过setTimeout()来完成这个工作： 123456789101112var xhr = new XMLHttpRequest (); xhr.onreadystatechange = function () &#123; if (this.readyState == 4) &#123; clearTimeout(timeout); // do something with response data &#125; &#125; var timeout = setTimeout( function () &#123; xhr.abort(); // call error callback &#125;, 60*1000 /* timeout after a minute */ ); xhr.open('GET', url, true); xhr.send(); 同时需要注意的是，不要同时发起多个XMLHttpRequests请求。 42、处理WebSocket的超时通常情况下，WebSocket连接创建后，如果30秒内没有任何活动，服务器端会对连接进行超时处理，防火墙也可以对单位周期没有活动的连接进行超时处理。 为了防止这种情况的发生，可以每隔一定时间，往服务器发送一条空的消息。可以通过下面这两个函数来实现这个需求，一个用于使连接保持活动状态，另一个专门用于结束这个状态。 12345678910111213var timerID = 0; function keepAlive() &#123; var timeout = 15000; if (webSocket.readyState == webSocket.OPEN) &#123; webSocket.send(''); &#125; timerId = setTimeout(keepAlive, timeout); &#125; function cancelKeepAlive() &#123; if (timerId) &#123; cancelTimeout(timerId); &#125; &#125; keepAlive()函数可以放在WebSocket连接的onOpen()方法的最后面，cancelKeepAlive()放在onClose()方法的最末尾。 43、时间注意原始操作符比函数调用快，使用VanillaJS比如，一般不要这样： 12var min = Math.min(a,b); A.push(v); 可以这样来代替： 12var min = a &lt; b ? a : b; A[A.length] = v; 44、开发时注意代码结构，上线前检查并压缩JavaScript代码别忘了在写代码时使用一个代码美化工具。使用JSLint(一个语法检查工具)并且在上线前压缩代码（比如使用JSMin）。 注：现在代码压缩一般推荐 UglifyJS (https://github.com/mishoo/UglifyJS2) 45、JavaScript博大精深，这里有些不错的学习资源 Code Academy资源：http://www.codecademy.com/tracks/javascript Marjin Haverbekex编写的Eloquent JavaScript：http://eloquentjavascript.net/ John Resig编写的Advanced JavaScript：http://ejohn.org/apps/learn/","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"如何在Mac OS中启动IPv6","slug":"如何在Mac OS中启动IPv6","date":"2018-02-01T15:56:23.000Z","updated":"2018-07-26T07:08:26.520Z","comments":true,"path":"2018/02/01/如何在Mac OS中启动IPv6/","link":"","permalink":"http://007sair.github.io/2018/02/01/如何在Mac OS中启动IPv6/","excerpt":"在使用xx-net时，遇到一个瓶颈问题：开启IPv6，记录如下~ 一、安装miredo和tuntaposx进入IPv6 Mac，使用的第一种方法teredo。","text":"在使用xx-net时，遇到一个瓶颈问题：开启IPv6，记录如下~ 一、安装miredo和tuntaposx进入IPv6 Mac，使用的第一种方法teredo。 先安装miredo，但是我的mac版本是10.13.1，提示软件与系统不兼容，处理方法： 重启mac，进入恢复模式（重启后长按Command + R）,x掉中间的弹层； 在顶部bar中打开终端打开，输入csrutil disable； 重启mac。 再安装tuntaposx，然后在系统偏好设置最下面有个Miredo，打开后是绿灯就b表示安装成功。 二、安装chrome扩展程序 在chrome浏览器中输入chrome://extensions； 打开XX-Net/SwitchyOmega/目录，把SwitchyOmega.crx拖入第1步的页面内； 安装好后在地址栏的右侧会出现SwitchyOmega图标，点选项； 打开后左侧选择导入/导出，在右侧选项中选择从备份文件中恢复，选择XX-Net/SwitchyOmega/OmegaOptions.bak； 左侧选择GAE-Proxy自动切换，点立即更新情景模式。 点这里进入\b\u001d详细文档 三、启动xx-netXX-Net目录下双击start或者命令行输入./start，启动后会弹出本地页面http://localhost:8085/?module=gae_proxy&amp;menu=status 点开顶部bar任务图标，选择Enabel Auto GAEProxy或者Enable Global GAEProxy，一个是自动代理，一个是全局代理。 然后点开地址栏右侧的SwitchyOmega，选择GAE-Proxy自动切换即可。 在本地页面中出现XX-Net 3.9.6，一切正常，你可以访问真正的互联网了。，\b就表示可以科学上网了~ 注意，如果合上电脑再打开，发现程序失效，请重启XX-Net","categories":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/categories/tool/"}],"tags":[{"name":"xx-net","slug":"xx-net","permalink":"http://007sair.github.io/tags/xx-net/"},{"name":"google","slug":"google","permalink":"http://007sair.github.io/tags/google/"}]},{"title":"git命令集","slug":"git命令集","date":"2018-01-24T06:04:23.000Z","updated":"2018-07-26T07:08:26.520Z","comments":true,"path":"2018/01/24/git命令集/","link":"","permalink":"http://007sair.github.io/2018/01/24/git命令集/","excerpt":"查看git当前用户名1git config --get user.name 查看git上个人代码量1git log --author=\"$(git config --get user.name)\" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc &#125;'","text":"查看git当前用户名1git config --get user.name 查看git上个人代码量1git log --author=\"$(git config --get user.name)\" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc &#125;' 统计每个人的增删行数1git log --format='%aN' | sort -u | while read name; do echo -en \"$name\\t\"; git log --author=\"$name\" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc &#125;' -; done 查看仓库提交者排名前 51git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5 查看全部排名只需去掉head管道 贡献者统计1git log --pretty='%aN' | sort -u | wc -l 提交数统计1git log --oneline | wc -l","categories":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/categories/tool/"}],"tags":[{"name":"git","slug":"git","permalink":"http://007sair.github.io/tags/git/"}]},{"title":"charles使用笔记","slug":"Charles-备忘","date":"2018-01-17T08:36:17.000Z","updated":"2018-07-26T07:08:26.520Z","comments":true,"path":"2018/01/17/Charles-备忘/","link":"","permalink":"http://007sair.github.io/2018/01/17/Charles-备忘/","excerpt":"记录使用charles的过程与遇到的一些坑。 准备工作在Charles 官方网站下载最新版的Charles安装包，是一个 dmg 后缀的文件。打开后将Charles拖到 Application 目录下即完成安装。本人版本是4.0.2。","text":"记录使用charles的过程与遇到的一些坑。 准备工作在Charles 官方网站下载最新版的Charles安装包，是一个 dmg 后缀的文件。打开后将Charles拖到 Application 目录下即完成安装。本人版本是4.0.2。 开始抓包将Charles设置成系统代理之前提到，Charles 是通过将自己设置成代理服务器来完成封包截取的，所以使用Charles的第一步是将其设置成系统的代理服务器。 启动Charles后，第一次Charles会请求你给它设置系统代理的权限。你可以输入登录密码授予Charles该权限。你也可以忽略该请求，然后在需要将Charles设置成系统代理时，选择菜单中的 &quot;Proxy&quot; -&gt; &quot;Mac OS X Proxy&quot; 来将Charles设置成系统代理。如下所示： 之后，你就可以看到源源不断的网络请求出现在Charles的界面中。 需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而Charles是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888 也可达到相同效果。 本人使用的XX-net代理，可在chrome下通过此插件设置系统代理 抓取手机数据包Charles 通常用来截取本地网络封包，但是当我们需要时，我们也可以用来截取其它设备上的网络请求。下面我就以 iPhone 为例，讲解如何进行相应操作。 charles上的设置要截取 iPhone 上的网络请求，我们首先需要将Charles的代理功能打开。在Charles的菜单栏上选择&quot;Proxy&quot;-&gt;&quot;Proxy Settings&quot;，填入代理端口 8888，并且勾上 &quot;Enable transparent HTTP proxying&quot; 就完成了在Charles上的设置。如下图所示: 手机上的设置首先我们需要获取Charles运行所在电脑的IP地址，Charles的顶部菜单的 &quot;Help&quot;-&gt;&quot;Local IP Address&quot;，即可在弹出的对话框中看到 IP 地址，如下图所示： 在 iPhone 的 &quot;设置&quot; -&gt; &quot;无线局域网&quot; 中，可以看到当前连接的wifi名，通过点击右边的详情键，可以看到当前连接上的wifi的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上Charles运行所在的电脑的 IP，以及端口号 8888，如下图所示： 设置好之后，我们打开iPhone上的任意需要网络通讯的程序，就可以看到Charles弹出iPhone请求连接的确认菜单（如下图所示），点击 &quot;Allow&quot; 即可完成设置。 截取https安装证书如果你需要截取分析Https协议相关的内容。那么需要安装Charles的 CA 证书。具体步骤如下。 首先我们需要在 Mac 电脑上安装证书。点击Charles的顶部菜单，选择 &quot;Help&quot; -&gt; &quot;SSL Proxying&quot; -&gt; &quot;InstallCharlesRoot Certificate&quot;，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图所示： 电脑端选择_图6_ 红框部分，然后需要对证书信任，之后会弹出钥匙串，如果不弹出，请自行打开钥匙串，如下图： 双击证书，选择始终信任 手机端选择_图6_ 绿框部分，在手机上输入弹出框中的链接地址进行安装 添加SSL Proxying证书安装完毕后，还需要对SSL做以下处理： 进入&quot;Proxy&quot; -&gt; &quot;SSL Proxying Settings&quot; 勾选&quot;Enable SSL Proxying&quot;，并点击下方的Add 在弹出的&quot;Edit Location&quot;中，输入Host和Port都为&quot;＊&quot;（看提示这样配置可以抓到所有https的包），然后进行添加 以上设置完毕后就可以正常抓取数据了。 代理本地文件我们在查找线上bug时，由于文件是压缩版或请求数据不可控，导致无法直接调试，此时一般会选择在本地环境模拟线上数据进行调试。 现在有了charles的Map Local功能，可以将线上文件代理成本地文件，达到修改本地文件，访问线上地址即可查看效果，步骤如下图： window中的Fiddler设置参考这篇文章 踩过的坑电脑端无法抓包问题原因： 确认两个代理设置是否正确，一是charles设置为系统代理：Mac OS X Proxy，二是浏览器也使用的系统代理。 若以上确认无误。分析为本地开启了vpn等翻墙工具。 解决方法： 关闭vpn翻墙工具 打开wifi中的网络偏好设置-&gt;高级-&gt;代理-&gt;不勾选 自动代理配置 重启charles 手机上安装了证书，仍然无法抓包？iphone系统更新到iOS 10.3后，https的请求都会失败，提示错误信息为Failure SSLHandshake: Received fatal alert: unknown_ca和You may need to configure your browser or application to trust the Charles Root Certificate. 然而之前任何问题都没有，并且相关设置都正确：Mac上安装了Charles的根证书，并且设置了始终信任，然后手机上也登录了http://chls.pro/ssl安装了描述文件,一切都按正常程序走的,但是错误始终无法解决。 问题原因： 虽然charles的根证书已经在安装列表中显示,但它是被关闭的。在iOS 10.3之前,当你将安装一个自定义证书,iOS会默认信任,不需要进一步的设置。而iOS 10.3之后,安装新的自定义证书默认是不受信任的。如果要信任已安装的自定义证书,需要手动打开开关以信任证书。 解决方法： 设置-&gt;通用-&gt;关于本机-&gt;证书信任设置-&gt;找到charles proxy custom root certificate然后信任该证书即可。 参考 Charles从入门到精通 Charles使用详解 Mac下使用charles遇到的问题以及解决办法","categories":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/categories/tool/"}],"tags":[{"name":"charles","slug":"charles","permalink":"http://007sair.github.io/tags/charles/"}]},{"title":"gulp-rev版本替换插件","slug":"gulp-rev","date":"2017-09-13T16:00:00.000Z","updated":"2018-07-26T07:08:26.519Z","comments":true,"path":"2017/09/14/gulp-rev/","link":"","permalink":"http://007sair.github.io/2017/09/14/gulp-rev/","excerpt":"脚手架中运行gulp build命令时会用到版本号插件，插件使用方法如下： 实现原理 解析js和css文件； 通过对js,css文件内容进行hash运算，生成一个文件的唯一hash字符串(如果文件修改则hash号会发生变化)； 替换html中的js,css文件名，生成一个带版本号的文件名。","text":"脚手架中运行gulp build命令时会用到版本号插件，插件使用方法如下： 实现原理 解析js和css文件； 通过对js,css文件内容进行hash运算，生成一个文件的唯一hash字符串(如果文件修改则hash号会发生变化)； 替换html中的js,css文件名，生成一个带版本号的文件名。 gulp-rev将资源文件（css、js、images等）解析，生成一个rev.json，大致如下： 1234&#123; \"main.css\": \"main-202dd5cd78.css\", \"svg.css\": \"svg-62b1ff821d.css\"&#125; gulp-rev-collector根据rev.json文件，将html内所有对应关系的资源文件名替换成json内的值 插件修改工具对文件的操作直接将文件名进行了修改，实际开发我们预想的rev.json应该是这样的 1234&#123; \"main.css\": \"main.css?v=202dd5cd78\", \"svg.css\": \"svg.css?v=62b1ff821d\"&#125; 修改方法： 123打开node_modules\\gulp-rev\\index.js第144行 manifest[originalFile] = revisionedFile;更新为: manifest[originalFile] = originalFile + &apos;?v=&apos; + file.revHash; 123打开nodemodules\\gulp-rev\\nodemodules\\rev-path\\index.js10行 return filename + &apos;-&apos; + hash + ext;更新为: return filename + ext; 123打开node_modules\\gulp-rev-collector\\index.js40行 let cleanReplacement = path.basename(json[key]).replace(new RegExp( opts.revSuffix ), &apos;&apos; );更新为: let cleanReplacement = path.basename(json[key]).split(&apos;?&apos;)[0] 踩到的坑版本问题： gulp-rev的版本8..0.0在我的脚手架的生成不了rev的json文件 解决方法：使用脚手架里的这个版本&quot;gulp-rev&quot;: &quot;^7.1.2&quot;,","categories":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/categories/tool/"}],"tags":[{"name":"坑","slug":"坑","permalink":"http://007sair.github.io/tags/坑/"},{"name":"gulp","slug":"gulp","permalink":"http://007sair.github.io/tags/gulp/"},{"name":"构建","slug":"构建","permalink":"http://007sair.github.io/tags/构建/"}]},{"title":"另辟蹊径之jsonp","slug":"jsonp-fun","date":"2017-09-13T16:00:00.000Z","updated":"2018-07-26T07:08:26.519Z","comments":true,"path":"2017/09/14/jsonp-fun/","link":"","permalink":"http://007sair.github.io/2017/09/14/jsonp-fun/","excerpt":"一段请求jsonp的接口返回的数据，如下： 1'callback(&#123;\"name\":\"sair\",\"data\":\"2017/09/14 14:31:00\"&#125;)'","text":"一段请求jsonp的接口返回的数据，如下： 1'callback(&#123;\"name\":\"sair\",\"data\":\"2017/09/14 14:31:00\"&#125;)' 这段数据在jq中直接被处理成了json对象，如： 123456789101112131415161718$.ajax(&#123; type: \"get\", url: \"http://x.xxx.xxx\", dataType: \"jsonp\", jsonp: \"callback\", jsonpCallback:\"jq_success\", success: function(res) &#123; //res =&gt; &#123;\"name\":\"sair\",\"data\":\"2017/09/14 14:31:00\"&#125; &#125;, error: function() &#123; console.log('fail'); &#125;&#125;);/*jsonp: 传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)jsonpCallback: 自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据*/ 那，除了jq，我们还有其他处理方法吗？ eval1eval('(' + 'callback(&#123;\"name\":\"sair\",\"data\":\"2017/09/14 14:31:00\"&#125;)' + ')'); 这样就变向的执行callback new Function()废话不多说，上代码： 12345678910111213141516171819//这个函数为js自定义，修改数据在这里修改function callback(obj) &#123; console.log(obj.name);&#125;/** * 封装的函数，3个参数 * fn：上面声明的callback函数 * fnName：callback的字符串类型 * jsonp：jsonp返回的数据 */function jsonFunc(fn, fnName, jsonp) &#123; var sFunc = 'function('+ fnName +')&#123;'+ jsonp +'&#125;'; var fnFunc = new Function('return ' + sFunc)(); fnFunc(fn);&#125;//调用此函数会立即执行上面的callback函数jsonFunc(callback, 'callback', 'callback(&#123;\"name\":\"xxxx\"&#125;)')","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"jsonp","slug":"jsonp","permalink":"http://007sair.github.io/tags/jsonp/"}]},{"title":"em与rem笔记","slug":"rem-em","date":"2017-09-05T16:00:00.000Z","updated":"2018-07-26T07:08:26.519Z","comments":true,"path":"2017/09/06/rem-em/","link":"","permalink":"http://007sair.github.io/2017/09/06/rem-em/","excerpt":"em相对于父元素的font-size 计算公式： 11 ÷ 父元素的font-size × 需要转换的像素值 = em值 如果元素设置了字体大小，此元素的其他属性，如：border、width、height、padding、margin、line-height计算就需要安装这个公式： 11 ÷ 元素自身的font-size × 需要转换的像素值 = em值","text":"em相对于父元素的font-size 计算公式： 11 ÷ 父元素的font-size × 需要转换的像素值 = em值 如果元素设置了字体大小，此元素的其他属性，如：border、width、height、padding、margin、line-height计算就需要安装这个公式： 11 ÷ 元素自身的font-size × 需要转换的像素值 = em值 rem相对于根元素(html)的font-size 123456789101112131415function getRem(pwidth, prem) &#123; var html = document.getElementsByTagName(\"html\")[0]; var oWidth = document.body.clientWidth || document.documentElement.clientWidth; html.style.fontSize = oWidth / pwidth * prem + \"px\";&#125;window.onload = function () &#123; /** * 750: 设计稿大小 * 75：基数，将750设计稿分成10份，每份75px，页面宽度为750时，1rem = 75px */ getRem(750, 75)&#125;;window.onresize = function () &#123; getRem(750, 75)&#125;;","categories":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"em","slug":"em","permalink":"http://007sair.github.io/tags/em/"},{"name":"rem","slug":"rem","permalink":"http://007sair.github.io/tags/rem/"}]},{"title":"position:sticky的用法","slug":"sticky","date":"2017-09-04T16:00:00.000Z","updated":"2018-07-26T07:08:26.519Z","comments":true,"path":"2017/09/05/sticky/","link":"","permalink":"http://007sair.github.io/2017/09/05/sticky/","excerpt":"基本用法position:sticky，它是相对定位（position:relative）和固定定位（position:fixed）的混合。 使用它，我们不再用监听scroll事件，即可实现导航栏滚动绝对定位的效果。","text":"基本用法position:sticky，它是相对定位（position:relative）和固定定位（position:fixed）的混合。 使用它，我们不再用监听scroll事件，即可实现导航栏滚动绝对定位的效果。 12345.sticky &#123; position: sticky; position: -webkit-sticky; top: 0;&#125; 生效条件需要注意的是，使用该属性有几个必要条件，否则不会生效： 父元素不能overflow:hidden或者overflow:auto属性。 必须指定top、bottom、left、right4个值之一，否则只会处于相对定位 父元素的高度不能低于sticky元素的高度 sticky元素仅在其父元素内生效","categories":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"坑","slug":"坑","permalink":"http://007sair.github.io/tags/坑/"},{"name":"sticky","slug":"sticky","permalink":"http://007sair.github.io/tags/sticky/"}]},{"title":"我又回来啦！","slug":"hello-world","date":"2017-08-22T04:05:22.000Z","updated":"2018-07-26T07:08:26.521Z","comments":true,"path":"2017/08/22/hello-world/","link":"","permalink":"http://007sair.github.io/2017/08/22/hello-world/","excerpt":"","text":"博客顺利从jekyll转为Hexo，记录如下 常用命令12345678# 启动本地环境$ hexo s -g# 发布更新博客$ hexo d -g# 创建新文章$ hexo new \"pageName\" 更多命令和技巧参考hexo中文官网","categories":[{"name":"web","slug":"web","permalink":"http://007sair.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://007sair.github.io/tags/web/"},{"name":"hexo","slug":"hexo","permalink":"http://007sair.github.io/tags/hexo/"}]},{"title":"flex样式预览工具","slug":"flex-tool","date":"2017-07-06T16:00:00.000Z","updated":"2018-07-26T07:08:26.519Z","comments":true,"path":"2017/07/07/flex-tool/","link":"","permalink":"http://007sair.github.io/2017/07/07/flex-tool/","excerpt":"","text":"最近做项目时老是觉得要不停的查flex属性用法，甚至不爽。一怒之下写了个工具。 传送门：flex-tool","categories":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/tags/tool/"},{"name":"flex","slug":"flex","permalink":"http://007sair.github.io/tags/flex/"}]},{"title":"VSCODE 常用快捷键","slug":"Visual-Studio-Code-CNKEYMAP","date":"2017-07-04T16:00:00.000Z","updated":"2018-07-26T07:08:26.518Z","comments":true,"path":"2017/07/05/Visual-Studio-Code-CNKEYMAP/","link":"","permalink":"http://007sair.github.io/2017/07/05/Visual-Studio-Code-CNKEYMAP/","excerpt":"官方版本 vscode快捷键有5种组合方式 Ctrl+Shift+? 常规组合 Ctrl+K F 先组合后单键组合方式 Ctrl+V Ctrl+V 同时依赖一个按键的组合 Alt+mouseClick 按键+鼠标点击 Alt+mouseDrag 按键+鼠标拖拽 全局命令面板Ctrl+Shift+P/F1 展示全局命令面板 Ctrl+P 模式在Ctrl+P下输入&gt;又可以回到主命令框Ctrl+Shift+P/F1模式。","text":"官方版本 vscode快捷键有5种组合方式 Ctrl+Shift+? 常规组合 Ctrl+K F 先组合后单键组合方式 Ctrl+V Ctrl+V 同时依赖一个按键的组合 Alt+mouseClick 按键+鼠标点击 Alt+mouseDrag 按键+鼠标拖拽 全局命令面板Ctrl+Shift+P/F1 展示全局命令面板 Ctrl+P 模式在Ctrl+P下输入&gt;又可以回到主命令框Ctrl+Shift+P/F1模式。 在Ctrl+P窗口下还可以 直接输入文件名，快速打开文件 ? 列出当前可执行的动作 ! 显示ERRORS或WARNINGS，也可以Ctrl+Shift+M : 跳转到行数，也可以Ctrl+G直接进入 @ 跳转到SYMBOL（搜索变量或者函数），也可以Ctrl+Shift+O直接进入 # 根据名字查找SYMBOL，也可以Ctrl+T 编辑器 &amp; 窗口打开多个窗口（多项目） 打开新编辑器窗口：Ctrl+Shift+N 打开终端 Ctrl+~ 创建新的终端 Ctrl+Shift+~ 打开多个文件（多文件） 新建文件 Ctrl+N 打开的文件之间切换 Ctrl+Tab，Alt+Left，Alt+Right 切出一个新的编辑器（最多3个）Ctrl+\\，也可以按住Ctrl鼠标点击EXPLORER里的文件名 左中右3个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3 编辑器换位置 Ctrl+K Left/Right 切换标签页的位置 Ctrl+Shift+PgUp/PgDown 多窗口标签页移动 Ctrl+Alt+Left/Right 代码编辑格式调整 缩进 Ctrl+[，Ctrl+] 折叠/展开代码块 Ctrl+Shift+[，Ctrl+Shift+] 折叠/展开所有子区域代码 Ctrl+k Ctrl+[，Ctrl+k Ctrl+] 代码格式化 Shift+Alt+F，或Ctrl+Shift+P后输入format code 复制剪切一整行，不选中 Ctrl+C/X，Ctrl+V 上下移动一行：Alt+Up/Down 向上向下复制一行：Shift+Alt+Up/Down 在当前行下/行上边插入一行 Ctrl+ENTER/Ctrl+Shift+ENTER 光标相关 列选择 Alt+Shifr+鼠标左键 移动到行首 Home 移动到行尾 End 移动到文件结尾 Ctrl+End 移动到文件开头 Ctrl+Home 移动到后半个括号 Ctrl+Shift+| 选中当前行 Ctrl+I，多次按下选中向下内容 选择从光标到行尾 Shift+End 选择从行首到光标处 Shift+Home 删除光标所在行 Ctrl+Delete shrink/expand selection（光标所在单词，文档高亮显示相同的）：Shift+Alt+Left和Shift+Alt+Right Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click添加cursor 翻转IDE Ctrl+Alt+Down 或 Ctrl+Alt+Up 光标跳到多行选中文本末尾 Ctrl+Shift+L Ctrl+D 下一个匹配的也被选中(被我自定义成删除当前行了，见下边Ctrl+Shift+K) 回退上一个光标操作 Ctrl+U 行视图上下移动 Ctrl+Up/Down 屏视图上下移动 Alt+Up/Down 代码相关 跳转到定义处 F12 定义处缩略图：只看一眼而不跳转过去 Alt+F12 列出所有的引用 Shift+F12 同时修改本文件中所有匹配的 Ctrl+F2 批量重命名：比如要修改一个方法名，可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了。 跳转到下一个Error或Warning：当有多个错误时可以按F8逐个跳转 比较文件，在左侧边栏里选择文件右键 选择以进行比较，然后需要对比的文件上右键选择与xxx比较。 查找替换 查找 Ctrl+F 查找替换 Ctrl+H 查询下一个/上一个 F3/Shift+F3 或 Enter/Shift Enter 选中所有出现在查询中的 Alt + Enter 整个文件夹中查找 Ctrl+Shift+F 匹配符： * to match one or more characters in a path segment ? to match on one character in a path segment ** to match any number of path segments ,including none {} to groUp conditions (e.g. {/*.html,/*.txt} matches all html and txt files) [] to declare a range of characters to match (e.g., example.[0-9] to match on example.0,example.1, … 显示相关 全屏 F11 缩放 Ctrl + = / Ctrl + - 侧边栏显/隐 Ctrl+B 侧边栏4大功能显示： 打开资源 Ctrl+Shift+E 打开搜索 Ctrl+Shift+F 打开GIT Ctrl+Shift+G 打开调试 Ctrl+Shift+D 打开扩展 Ctrl+Shift+X 输出Show Output Ctrl+Shift+U 预览markDown Ctrl+Shift+V 其他自动保存：File -&gt; AutoSave ，或者Ctrl+Shift+P，输入 auto","categories":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/tags/tool/"},{"name":"vscode","slug":"vscode","permalink":"http://007sair.github.io/tags/vscode/"}]},{"title":"苹方字体在H5的应用","slug":"font-pingfang","date":"2017-03-13T16:00:00.000Z","updated":"2018-07-26T07:08:26.518Z","comments":true,"path":"2017/03/14/font-pingfang/","link":"","permalink":"http://007sair.github.io/2017/03/14/font-pingfang/","excerpt":"苹方字体在手机端的展示效果如下： 苹方字体苹方-简 测试字体 123456789 abcdefg ABCDEFG 苹方-简 常规体 测试字体 123456789 abcdefg ABCDEFG","text":"苹方字体在手机端的展示效果如下： 苹方字体苹方-简 测试字体 123456789 abcdefg ABCDEFG 苹方-简 常规体 测试字体 123456789 abcdefg ABCDEFG 苹方-简 常规体 测试字体 123456789 abcdefg ABCDEFG 苹方-简 常规体 测试字体 123456789 abcdefg ABCDEFG 苹方-简 极细体 测试字体 123456789 abcdefg ABCDEFG 苹方-简 细体 测试字体 123456789 abcdefg ABCDEFG 苹方-简 纤细体 测试字体 123456789 abcdefg ABCDEFG 苹方-简 中黑体 测试字体 123456789 abcdefg ABCDEFG 苹方-简 中粗体 测试字体 123456789 abcdefg ABCDEFG San Francisco测试字体 123456789 abcdefg ABCDEFG -apple-system 测试字体 123456789 abcdefg ABCDEFG 参考自：http://stackoverflow.com/questions/32660748/how-to-use-apples-new-san-francisco-font-on-a-webpage","categories":[{"name":"test","slug":"test","permalink":"http://007sair.github.io/categories/test/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"test","slug":"test","permalink":"http://007sair.github.io/tags/test/"},{"name":"font","slug":"font","permalink":"http://007sair.github.io/tags/font/"}]},{"title":"怎么把孩子养到18岁，神志正常还不恨你","slug":"How-to-get-your-kids-to-18-sane-and-not-hating-you","date":"2017-03-02T16:00:00.000Z","updated":"2018-07-26T07:08:26.518Z","comments":true,"path":"2017/03/03/How-to-get-your-kids-to-18-sane-and-not-hating-you/","link":"","permalink":"http://007sair.github.io/2017/03/03/How-to-get-your-kids-to-18-sane-and-not-hating-you/","excerpt":"译文，来自：How to get your kids to 18, sane and not hating you 七位作者为大家讲述父母之道，都是他们希望在开始时就懂得的事 最艰难的客户我第一次怀孕的时候，还是一个装逼的公司律师，习惯于自作主张。我真正需要的就是那时有人告诉我：“了解你最坏的客户吧？就那个半夜两点给你打电话，只为告诉你你多差劲的那家伙；或者那个突然就需要什么莫名的表格的混蛋，你只好翻天翻地给他找，找到了他又发火说那不是他想要的东西，虽然这确实是他要的。恭喜啊，现在你就同一个小小版的客户生活在一起了。悲哀的是，你学过的一切对这个新客户都还没有一点用处。”","text":"译文，来自：How to get your kids to 18, sane and not hating you 七位作者为大家讲述父母之道，都是他们希望在开始时就懂得的事 最艰难的客户我第一次怀孕的时候，还是一个装逼的公司律师，习惯于自作主张。我真正需要的就是那时有人告诉我：“了解你最坏的客户吧？就那个半夜两点给你打电话，只为告诉你你多差劲的那家伙；或者那个突然就需要什么莫名的表格的混蛋，你只好翻天翻地给他找，找到了他又发火说那不是他想要的东西，虽然这确实是他要的。恭喜啊，现在你就同一个小小版的客户生活在一起了。悲哀的是，你学过的一切对这个新客户都还没有一点用处。” “你就是写上一封措辞冷酷的信给他们，你的小宝宝也不会自动去吃晚上10点的奶，小家伙也不会想去穿袜子。你需要学习新技巧，还得够强悍——耐心、娱乐、最傻逼的喜剧——就是这样也还是要做好失败的准备，经常的失败。扔掉你现有的成功秘诀。孩子开始睡整觉不是你的成功，他们直到10岁还是只吃小块奶酪也不算是失败。你唯一的目标是把他们养到18岁，活着，清醒，还不恨你。没有奖励计划，但是工作的满意度倒还不差。祝好运。” Emma Beddington 我希望我能更有母爱我希望有人能告诉我，在像个烈士一样溺爱孩子与只是给他们关注之间有巨大的差别。现在我想，在培养独立又灵活的孩子这个期望上，我太死脑筋了，对他们的独特需求同情不够。让我吞下这个苦果有点困难，这一点我们（两个20多的成年孩子，还有一个仍然在家的15岁孩子）都得同意这一点。然后我们也会抱一抱。 我仍然完全反对那种育儿风格，就是给孩子清理掉所有障碍，让他们永远不需要自己面对难题。牛津大学心理咨询的头，心理学家Alan Percy说过，如果父母做了所有的事，就会让孩子什么都不会——他还说，这也会让孩子对父母感到憎恨与愤怒。但是，对我和孩子们来说，在关爱、养育方面略多一点可能会更好。你可以陪孩子玩，聊天，同时培养他们的未来能力的时间很快就结束了。 Louise Chunn，Welldoing.org的创始人。 打闹可以让小孩子放松最好最简单的建议就是同周围的人交往并且咨询他们的意见。别的还需要做什么？ 我很幸运同正确的人一起生孩子。很多人不是这样。他必须是有同样基本价值观的人，还要能忍受你最疯狂的梦想，还要有无限的耐心、友善、幽默以及热情。他必须要同样的重视你，否则，还是养条狗吧。 第一年还是很容易的——只要你认识到一个现实：你的时间再也不是你的了。 对小孩子，你不能太善良或者太有耐心。在遇到难题时，你第一个反应应该是打闹。小孩子是地球上最搞笑的东西了：就像袋熊那样野，同时又有人的特点和习性。 你现在需要每天早起，所有节假日也不例外，这个要持续14年。然后，你的生物钟就会改变，你会在早上8点冲进年轻人的房间，大叫半天都过完了。 碰到周末睡睡觉实在没有任何不对的。 Mike Power 我还没有准备好他们就到青春期了我很享受早几年当父母的感觉。隐藏在我身体里的和我们父亲一样的物质开始浮现出来。用我女儿的话说，我是个快乐爸爸。 我没准备的事就是青春期。那种情绪波动，无法理解的愤怒，还有我女儿整天都躲在自己屋子里只在吃饭时出来还要跟她弟弟打架，这些都很难对付。我没处理好青春期这些事，让我跟两个孩子的关系都变糟了，然后这个关系再也没有恢复过来。 我现在知道我没有经过典型的青春期。我喜欢我的父母，我慢慢的远离他们。从来没有大喊大叫，也没有争吵。我们呆在一起都很舒服，然后我就去上大学，工作，结婚，再回去就是个成年人了。对我自己的两个孩子个性突变这个事，我一点准备都没有。 我希望能有人在头10年就给我解释清楚：“现在你同你的天使们时光正好，但是他们会变，变得无可理喻的可怕，你必须做好准备，还得一起摇摆。” Adrian Mourby 别像我这样我的两个男孩现在都长大了，有他们自己的生活。我很年轻就生了他们，一个接一个，只能快点啦。所以我的第一个建议是不要在不够成熟，不能负担这个责任时生孩子——说起来容易。 教育孩子说请，谢谢，对不起，从他们说话起就教——这能让他们在周围更有礼貌，也让他们的人生更顺利。 教育孩子友善，为他人着想，但是你必须自己做好榜样。想让别人怎么对你，就怎么对别人，是个老话，但很有用。 早点分配家务，搞的有趣点，让它成为第二天性。否则就是自己的负担。有个朋友，她女儿22了，还住在家里，甚至都不收盘子，用过的杯子也到处乱放。你说谁来收拾，还像个老妇人一样唠叨？ 对吃的放松点。如果老担心他们不吃蔬菜或者其他东西，孩子就会越来越拒绝，就是说不。特别是如果他们看你难受很有意思的话。孩子饿了自然会吃——他们不是殉道者——到时候不管是花椰菜还是牛脸肉他们都会吃。一旦他们开始吃硬的，就不要再给他们搞什么单独的吃，那只会让他们挑剔。如果他们跟你吃一样的——最好还是在一个桌子上——他们会喜欢各种吃的，也会对新味道新东西感兴趣。 如果在陪孩子就不要多看手机，那会让他们觉得屏幕比人还重要，他们会烦躁，会大叫——到时候又怎么批评他们呢？ Rachel Douglas 遵循你的直觉扔了育儿书，这是某个出版过一本书的人说的。我关于早期当妈的最悲惨的记忆，无过于把Gina Ford的书Contented Little Baby用在我的小孩身上，他可是超级不服从。固定时间，在黑屋子里喂奶，不进行目光接触？结果呢？孩子哭闹，妈妈悲惨。我一度想遵从专家的意见，建立起主导地位和规矩，认为这是对的。这不对。在那些天里能让我自信的就只有遵从我自己的直觉。 几周后，我就把那本书扔了，我睡到沙发上，他想吃就喂。孩子想吃的时候就会想让你喂（差不多是随时），这完全自然啊。但时不时的，如果人不能遵守精确的规程，我还是觉得很失败。还有个睡觉“专家” Richard Ferber，他有另外一个战场，很快我也把他的书扔了。 Annabel Karmel的做饭书我是不看了。它不是严格的育儿书，但还是搞出一套儿童应该吃什么的处方，只会让你在孩子不吃自己做的燕麦卷非要吃垃圾食品时感到罪恶感。我的三个孩子都这样。 育儿，儿童教育，这些我全买了，现在它们都在书架顶上吃灰。它们本来就该在那里，包括我自己的书，我还在其中有一章里写了为了孩子少看手机的几个方法。 我遵守了吗？我努力了，但是对最小的孩子，我还是太依赖iNanny了。现在她四岁了，几乎不看任何屏幕，反倒是ipad在吃灰了。所以说，不要看任何育儿建议——特别是你自己的。 Emma Cook 总是自己第一我的父母冷静、严格、坚忍。我的育儿经验就完全排斥这些——60年代，多愁善感，自由派。经常的玩闹和搞笑。这一套直到他们10岁还不错，然后就不行了。 那些50后的边界是根本的。我可能从来没那样做。你得庄重，像贵族那样。声名狼籍的现代性也不能消除它。吸上烟袋，穿上空心绒。全是绝对性。不要再说了。我的女儿们完全按它的反面来做。小心那些虚张声势和假装的漠不关心。 镇静剂对你没好处。 永远积极。活泼。这让我受够了。学着享受胡言乱语吧，特别是他们15岁到35岁的时候。 不要当老师——大多数老师的孩子都傻头傻脑的。我本应知道的。 不要过分刺激他们的小心灵。不要从刚出生就在睡觉时放莫扎特，或者在摇蓝上挂行星。我们做了。这让他们看上去过分聪明，还有点失职。 综上，不要对街头混混，考试工厂，K粉，蜘蛛纹身还有什么就要来临的末日忧虑。这很有意思。 总是把自己放在第一位。然后试着用温和的忽视，绝对的爱还有更多的戏谑来达成幸福。轻如和风。Ian Whitwham","categories":[{"name":"life","slug":"life","permalink":"http://007sair.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"http://007sair.github.io/tags/life/"}]},{"title":"Date对象在移动端的坑","slug":"date-keng","date":"2017-02-28T16:00:00.000Z","updated":"2018-07-26T07:08:26.518Z","comments":true,"path":"2017/03/01/date-keng/","link":"","permalink":"http://007sair.github.io/2017/03/01/date-keng/","excerpt":"本文描述了工作中涉及Date对象都是一些坑的写法。 涉及移动端，测试时userAgent如下： PC 1234567// ChromeMozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36// SafariMozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2 Mobile","text":"本文描述了工作中涉及Date对象都是一些坑的写法。 涉及移动端，测试时userAgent如下： PC 1234567// ChromeMozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.87 Safari/537.36// SafariMozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2 Mobile 1234567// 微信Mozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 like Mac OS X) AppleWebKit/602.4.6 (KHTML, like Gecko) Mobile/14D27 MicroMessenger/6.5.5 NetType/WIFI Language/zh_CN// SafariMozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 like Mac OS X) AppleWebKit/602.4.6 (KHTML, like Gecko) Version/10.0 Mobile/14D27 Safari/602.1 测试过程先来看一段代码： 12345if ( new Date().getTime() &lt;= new Date('2020/03/01 24:00:00').getTime() ) &#123; alert('true');&#125; else &#123; alert('false')&#125; 输出结果毫无疑问： 1true 坑来了~ 在我的手机里，输出结果却是false 别着急，我们一步步来找原因。 先来看看new Date(&#39;2020/03/01 24:00:00&#39;)在PC和手机的输出： 12345// PCMon Mar 02 2020 00:00:00 GMT+0800 (ä¸­å½æ åæ¶é´)// MobileInvalid Date 很明显，24:00:00这种写法在手机端被视为无效时间！ PS：还有一种写法在手机端也被视为无效时间：new Date(&#39;2020-03-01 12:00:00&#39;) 那无效时间转成时间戳会是什么呢？答案：NaN 然后我们来测试任何数跟NaN作比较： 123456789101110000 &gt; NaN // false10000 &lt; NaN // false-5 &lt; NaN //false'1000000' &lt; NaN // falsenull &lt; NaN // falseundefined &lt; NaN // false[] &lt; NaN // falseObject &lt; NaN // falseNaN &lt; NaN // falseNaN == NaN // falseNaN === NaN // false 总结 new Date的24:00:00在移动端&amp;PC(safari)浏览器中会被视为无效时间 2017-03-01 12:00:00的横线写法在移动端&amp;PC(safari)浏览器中会被视为无效时间 无效时间经过时间戳转换后会变为NaN","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"坑","slug":"坑","permalink":"http://007sair.github.io/tags/坑/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"Date对象","slug":"Date对象","permalink":"http://007sair.github.io/tags/Date对象/"}]},{"title":"css选择器总结","slug":"css-selector","date":"2017-02-05T16:00:00.000Z","updated":"2018-07-26T07:08:26.517Z","comments":true,"path":"2017/02/06/css-selector/","link":"","permalink":"http://007sair.github.io/2017/02/06/css-selector/","excerpt":"td{font-family: Verdana, Geneva, sans-serif;font-size: 13px;} 约定：IE7+ 意思为大于（含IE7）的浏览器 CSS1 &amp; CSS2.1 选择器基础选择器 选择器 例子 例子描述 兼容性 * * 选择所有元素。 all E p 选择所有 &lt;p&gt; 元素。 all #id #firstname 选择 id=&quot;firstname&quot; 的所有元素。 all .class .intro 选择 class=&quot;intro&quot; 的所有元素。 all","text":"td{font-family: Verdana, Geneva, sans-serif;font-size: 13px;} 约定：IE7+ 意思为大于（含IE7）的浏览器 CSS1 &amp; CSS2.1 选择器基础选择器 选择器 例子 例子描述 兼容性 * * 选择所有元素。 all E p 选择所有 &lt;p&gt; 元素。 all #id #firstname 选择 id=&quot;firstname&quot; 的所有元素。 all .class .intro 选择 class=&quot;intro&quot; 的所有元素。 all 组合选择器 选择器 例子 例子描述 兼容性 E,F div,p 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。 all E F div p 选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素。 all E &gt; F div&gt;p 选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素。 IE7+ E + F div+p 选择紧接在 &lt;div&gt; 元素之后的所有 &lt;p&gt; 元素。 IE7+ 属性选择器 选择器 例子 例子描述 兼容性 E[att] [target] 选择带有 target 属性所有元素。 IE7+ E[att=val] [target=_blank] 选择 target=&quot;_blank&quot; 的所有元素。 IE7+ E[att~=val] [title~=flower] 选择 title 属性包含单词 &quot;flower&quot; 的所有元素。 IE7+ E[att=val] [lang=en] 选择 lang 属性值以 &quot;en&quot; 开头的所有元素。 IE7+ 伪元素 选择器 例子 例子描述 兼容性 E:first-line p:first-line 选择每个 &lt;p&gt; 元素的首行。 IE7+ E:first-letter p:first-letter 选择每个 &lt;p&gt; 元素的首字母。 IE7+ E:before p:before 在每个 &lt;p&gt; 元素的内容之前插入内容。 IE8+ E:after p:after 在每个 &lt;p&gt; 元素的内容之后插入内容。 IE8+ 伪类 选择器 例子 例子描述 兼容性 E:first-child p:first-child 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。 IE7+ E:link a:link 选择所有未被访问的链接。 all E:visited a:visited 选择所有已被访问的链接。 all E:active a:active 选择活动链接。 all E:hover a:hover 选择鼠标指针位于其上的链接。 IE6+(?) E:focus input:focu 选择获得焦点的 input 元素。 IE8+ E:lang(c) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 &lt;p&gt; 元素。 IE7+ CSS 2.1 selectors Known issues (6): IE6 does not properly support combinations of pseudo classes like :link, :active and :visited IE8-11 does not update an element’s :hover status when scrolling without moving the pointer. Safari 5.1 and Android browsers do not support the adjacent selector if the adjacent element is a “nav” element. :first-child fails in IE7 if the first child is a comment. IE7 doesn’t support all pseudo classes (like :focus) or pseudo elements (like :before and :after) In IE10 adjacent sibling selector doesn’t work with pseudo-class in case of E:active F. CSS3选择器同级元素通用选择器 选择器 例子 例子描述 兼容性 E ~ F p~ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。 IE7+ 属性选择器 选择器 例子 例子描述 兼容性 E[att^=&quot;val&quot;] a[src^=&quot;https&quot;] 选择其 src 属性值以 &quot;https&quot; 开头的每个 &lt;a&gt; 元素。 IE7+ E[att$=&quot;val&quot;] a[src$=&quot;.pdf&quot;] 选择其 src 属性以 &quot;.pdf&quot; 结尾的所有 &lt;a&gt; 元素。 IE7+ E[att*=&quot;val&quot;] a[src*=&quot;abc&quot;] 选择其 src 属性中包含 &quot;abc&quot; 子串的每个 &lt;a&gt; 元素。 IE7+ 与用户界面有关的伪类 选择器 例子 例子描述 兼容性 E:enabled input:enabled 选择每个启用的 &lt;input&gt; 元素。 IE9+ E:disabled input:disabled 选择每个禁用的 &lt;input&gt; 元素 IE9+ E:checked input:checked 选择每个被选中的 &lt;input&gt; 元素。 IE9+ E::selection ::selection 选择被用户选取的元素部分。 IE9+ 结构性伪类 选择器 例子 例子描述 兼容性 E:root :root 选择文档的根元素。 IE9+ E:nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 IE9+ E:nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 IE9+ E:nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 IE9+ E:nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 IE9+ E:last-child p:last-child 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。 IE9+ E:first-of-type p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 IE9+ E:last-of-type p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 IE9+ E:only-child p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 IE9+ E:only-of-type p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 IE9+ E:empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。 IE9+ 其他伪类 选择器 例子 例子描述 兼容性 E:not(s) :not(p) 选择非 &lt;p&gt; 元素的每个元素。 IE9+ E:target #news:target 选择当前活动的 #news 元素。 IE9+ CSS 3 selectors Known issues (4): iOS 9 has a bug in WebViews (not Safari) with the CSS sibling selector IE9-IE11 supports :empty but will not repaint/relayout the page if content is added/removed from an :empty selected element iOS 8 Safari has issues with nth-child. Android 4.3 and lower (together with older WebKit browsers) have issues when combining pseudo classes with adjacent or general sibling selectors. 结论： css1少数选择器不支持ie6，其他全支持 css2.1不支持ie6 css3不支持ie6，少数在ie7 8上也不支持 参考： CSS 选择器参考手册 Can i use CSS选择器的浏览器支持","categories":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"css选择器","slug":"css选择器","permalink":"http://007sair.github.io/tags/css选择器/"}]},{"title":"word-wrap与word-break的区别","slug":"wordbreak","date":"2016-07-24T16:00:00.000Z","updated":"2018-07-26T07:08:26.517Z","comments":true,"path":"2016/07/25/wordbreak/","link":"","permalink":"http://007sair.github.io/2016/07/25/wordbreak/","excerpt":"div{ word-break: normal; word-wrap: normal; } .test{ margin-bottom: 2px; width: 230px; border: 1px solid red; } .c1{} .c2{ word-wrap:break-word;} .c3{ word-wrap:break-word;word-break:break-all;} .c4{ word-wrap:break-word;word-break:keep-all;} .c5{ word-break:break-all;} .c6{ word-break:keep-all;} 换行问题自古以来就是一个难题，写了几个例子，先来看看，没有耐心的可以直接点这里 定义word-wrapword-wrap 属性允许长单词或 URL 地址换行到下一行。 语法 1word-wrap: normal | break-word; 值 描述 normal 只在允许的断字点换行（浏览器保持默认处理）。 break-word 在长单词或 URL 地址内部进行换行。","text":"div{ word-break: normal; word-wrap: normal; } .test{ margin-bottom: 2px; width: 230px; border: 1px solid red; } .c1{} .c2{ word-wrap:break-word;} .c3{ word-wrap:break-word;word-break:break-all;} .c4{ word-wrap:break-word;word-break:keep-all;} .c5{ word-break:break-all;} .c6{ word-break:keep-all;} 换行问题自古以来就是一个难题，写了几个例子，先来看看，没有耐心的可以直接点这里 定义word-wrapword-wrap 属性允许长单词或 URL 地址换行到下一行。 语法 1word-wrap: normal | break-word; 值 描述 normal 只在允许的断字点换行（浏览器保持默认处理）。 break-word 在长单词或 URL 地址内部进行换行。 word-breakword-break 属性规定自动换行的处理方法。 语法 1word-break: normal | break-all | keep-all; 值 描述 normal 使用浏览器默认的换行规则。 break-all 允许在单词内换行。 keep-all 只能在半角空格或连字符处换行。 开始测试为了方便测试，先将div的word-break与word-wrap改成normal，以下测试均为数字、字母、单词、汉字、汉字+单词混排在div中的表现情况 默认无任何换行样式123.c1 &#123; /* 无任何样式 */&#125; 11111111111111111111111111111111111111111111111111111aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaThis is all English. This is all English. This is all English. 全是中文的情况。全是中文的情况。全是中文的情况。 中英文混排的情况。Chinese and English. 中英文混排的情况。Chinese and English. word-wrap: break-word123.c2 &#123; word-wrap: break-word;&#125; 111111111111111111111111111111111111111111111111111111111 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa This is all English. This is all English. This is all English. 全是中文的情况。全是中文的情况。全是中文的情况。中英文混排的情况。Chinese and English. 中英文混排的情况。Chinese and English. word-break: break-all;123.c5 &#123; word-break: break-all;&#125; 111111111111111111111111111111111111111111111111111111111 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa This is all English. This is all English. This is all English. 全是中文的情况。全是中文的情况。全是中文的情况。中英文混排的情况。Chinese and English. 中英文混排的情况。Chinese and English. word-wrap: break-word; word-break: break-all;1234.c3 &#123; word-wrap: break-word; word-break: break-all;&#125; 111111111111111111111111111111111111111111111111111111111 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa This is all English. This is all English. This is all English. 全是中文的情况。全是中文的情况。全是中文的情况。中英文混排的情况。Chinese and English. 中英文混排的情况。Chinese and English. word-wrap: break-word; word-break: keep-all;1234.c4 &#123; word-wrap: break-word; word-break: keep-all;&#125; 111111111111111111111111111111111111111111111111111111111 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa This is all English. This is all English. This is all English. 全是中文的情况。全是中文的情况。全是中文的情况。中英文混排的情况。Chinese and English. 中英文混排的情况。Chinese and English. word-break: keep-all;123.c6 &#123; word-break: keep-all;&#125; 111111111111111111111111111111111111111111111111111111111 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa This is all English. This is all English. This is all English. 全是中文的情况。全是中文的情况。全是中文的情况。中英文混排的情况。Chinese and English. 中英文混排的情况。Chinese and English. 结论 word-wrap 强调的是是否允许单词内断句。 normal: 单词太长，换行显示，再超过一行就溢出显示。 break-word: 当单词太长时，先尝试换行，换行后还是太长，单词内还可以换行。 word-break 强调的则是怎么样来进行单词内的断句。 break-all: 强行上，挤不下的话剩下的就换下一行显示呗。霸道型。 keep-all: 放不下我了，那我就另起一行展示，再放不下，我也不退缩。傲骄型。 事实上，word-wrap:break-word与word-break:break-all共同点是都能把长单词强行断句，不同点是word-wrap:break-word会首先起一个新行来放置长单词，新的行还是放不下这个长单词则会对长单词进行强制断句；而word-break:break-all则不会把长单词放在一个新行里，当这一行放不下的时候就直接强制断句了。","categories":[{"name":"html","slug":"html","permalink":"http://007sair.github.io/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://007sair.github.io/tags/html/"},{"name":"换行","slug":"换行","permalink":"http://007sair.github.io/tags/换行/"}]},{"title":"HTML字符转义、特殊字符笔记","slug":"UNICODE","date":"2016-07-03T16:00:00.000Z","updated":"2018-07-26T07:08:26.516Z","comments":true,"path":"2016/07/04/UNICODE/","link":"","permalink":"http://007sair.github.io/2016/07/04/UNICODE/","excerpt":"转义字符串的由来HTML中&lt;，&gt;，&amp;等有特殊含义（&lt;，&gt;，用于链接签，&amp;用于转义），不能直接使用。这些符号是不显示在我们最终看到的网页里的，倘若我们需要在页面中显示这些字符，就需要用到转义字符串了。 转义字符串的组成一个完整的转义字符串，分为三个部分： 一个&amp;符号，英文为ampersand； 是实体名字或为#+实体编号； 一个;号； 例如，常用的大于号&gt;，使用转义字符串后的写法为&amp;gt;或&amp;#62; 我们注意到，上面的大于号使用了2种方式的转义，第一种称为实体名称，第二种为实体编号，区别在于实体名称的优点为便于记忆，但兼容性不完美，实体编号则反之。","text":"转义字符串的由来HTML中&lt;，&gt;，&amp;等有特殊含义（&lt;，&gt;，用于链接签，&amp;用于转义），不能直接使用。这些符号是不显示在我们最终看到的网页里的，倘若我们需要在页面中显示这些字符，就需要用到转义字符串了。 转义字符串的组成一个完整的转义字符串，分为三个部分： 一个&amp;符号，英文为ampersand； 是实体名字或为#+实体编号； 一个;号； 例如，常用的大于号&gt;，使用转义字符串后的写法为&amp;gt;或&amp;#62; 我们注意到，上面的大于号使用了2种方式的转义，第一种称为实体名称，第二种为实体编号，区别在于实体名称的优点为便于记忆，但兼容性不完美，实体编号则反之。 html特殊字符html本身存在很多的特殊字符，像我们常见的Copyright符号©，使用特殊字符需要注意以下几点： 这些字符属于unicode字符集，你的文档需要声明为utf-8; 这些字符在html、css、js中的书写方式各有不同，例如向左的箭头⇠，如下： HTML： &amp;#8672; CSS： \\21E0, css的写法需要加上反斜杠，常用在content属性中 JS： \\u21E0，js的写法需在css的基础上前面加个反斜杠+u 字符在各浏览器的表现略有区别，使用需谨慎 ⇠&nbsp;&nbsp;箭头类符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSS⇠&amp;#8672\\u21E021E0⇢&amp;#8674\\u21E221E2⇡&amp;#8673\\u21E121E1⇣&amp;#8675\\u21E321E3↞&amp;#8606\\u219E219E↠&amp;#8608\\u21A021A0↟&amp;#8607\\u219F219F↡&amp;#8609\\u21A121A1←&amp;#8592\\u21902190→&amp;#8594\\u21922192↑&amp;#8593\\u21912191↓&amp;#8595\\u21932193↔&amp;#8596\\u21942194↕&amp;#8597\\u21952195⇄&amp;#8644\\u21C421C4⇅&amp;#8645\\u21C521C5↢&amp;#8610\\u21A221A2↣&amp;#8611\\u21A321A3⇞&amp;#8670\\u21DE21DE⇟&amp;#8671\\u21DF21DF↫&amp;#8619\\u21AB21AB↬&amp;#8620\\u21AC21AC⇜&amp;#8668\\u21DC21DC⇝&amp;#8669\\u21DD21DD↚&amp;#8602\\u219A219A↛&amp;#8603\\u219B219B↮&amp;#8622\\u21AE21AE↭&amp;#8621\\u21AD21AD⇦&amp;#8678\\u21E621E6⇨&amp;#8680\\u21E821E8⇧&amp;#8679\\u21E721E7⇩&amp;#8681\\u21E921E9▲&amp;#9650\\u25B225B2►&amp;#9658\\u25BA25BA▼&amp;#9660\\u25BC25BC◄&amp;#9668\\u25C425C4➔&amp;#10132\\u27942794➙&amp;#10137\\u27992799➨&amp;#10152\\u27A827A8➲&amp;#10162\\u27B227B2➜&amp;#10140\\u279C279C➞&amp;#10142\\u279E279E➟&amp;#10143\\u279F279F➠&amp;#10144\\u27A027A0➤&amp;#10148\\u27A427A4➥&amp;#10149\\u27A527A5➦&amp;#10150\\u27A627A6➧&amp;#10151\\u27A727A7➵&amp;#10165\\u27B527B5➸&amp;#10168\\u27B827B8➼&amp;#10172\\u27BC27BC➽&amp;#10173\\u27BD27BD➺&amp;#10170\\u27BA27BA➳&amp;#10163\\u27B327B3↷&amp;#8631\\u21B721B7↶&amp;#8630\\u21B621B6↻&amp;#8635\\u21BB21BB↺&amp;#8634\\u21BA21BA↵&amp;#8629\\u21B521B5↯&amp;#8623\\u21AF21AF➾&amp;#10174\\u27BE27BE&nbsp;&nbsp;&nbsp;&nbsp; ❤&nbsp;&nbsp;基本形状类符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSS❤&amp;#10084\\u27642764✈&amp;#9992\\u27082708★&amp;#9733\\u26052605✦&amp;#10022\\u27262726☀&amp;#9728\\u26002600◆&amp;#9670\\u25C625C6◈&amp;#9672\\u25C825C8▣&amp;#9635\\u25A325A3☻&amp;#9787\\u263B263B☺&amp;#9786\\u263A263A☹&amp;#9785\\u26392639✉&amp;#9993\\u27092709☎&amp;#9742\\u260E260E☏&amp;#9743\\u260F260F✆&amp;#9990\\u270627060&amp;#65533\\uFFFDFFFD☁&amp;#9729\\u26012601☂&amp;#9730\\u26022602❄&amp;#10052\\u27442744☃&amp;#9731\\u26032603❈&amp;#10056\\u27482748✿&amp;#10047\\u273F273F❀&amp;#10048\\u27402740❁&amp;#10049\\u27412741☘&amp;#9752\\u26182618❦&amp;#10086\\u27662766☕&amp;#9749\\u97499749❂&amp;#10050\\u27422742☥&amp;#9765\\u26252625☮&amp;#9774\\u262E262E☯&amp;#9775\\u262F262F☪&amp;#9770\\u262A262A☤&amp;#9764\\u26242624✄&amp;#9988\\u27042704✂&amp;#9986\\u27022702☸&amp;#9784\\u26382638⚓&amp;#9875\\u26932693☣&amp;#9763\\u26232623⚠&amp;#9888\\u26A026A0⚡&amp;#9889\\u26A126A1☢&amp;#9762\\u26222622♻&amp;#9851\\u267B267B♿&amp;#9855\\u267F267F☠&amp;#9760\\u26202620 ¥&nbsp;&nbsp;货币类&lt;table class=”zfz_table “cellpadding=”8”cellspacing=”0”&gt;符号UNICODE符号&lt;th colspan=”3”class=”lasttd”&gt;UNICODEHTMLJSCSSHTMLJSCSS$&amp;#36\\u00240024¢&amp;#162\\u00A200A2£&amp;#163\\u00A300A3¤&amp;#164\\u00A400A4€&amp;#8364\\u20AC20AC¥&amp;#165\\u00A500A5₱&amp;#8369\\u20B120B1₹&amp;#8377\\u20B920B9 ½&nbsp;&nbsp;数学类&lt;table class=”zfz_table “cellpadding=”8”cellspacing=”0”&gt;符号UNICODE符号&lt;th colspan=”3”class=”lasttd”&gt;UNICODEHTMLJSCSSHTMLJSCSS½&amp;#189\\u00BD00BD¼&amp;#188\\u00BC00BC¾&amp;#190\\u00BE00BE⅓&amp;#8531\\u21532153⅔&amp;#8532\\u21542154⅛&amp;#8539\\u215B215B⅜&amp;#8540\\u215C215C⅝&amp;#8541\\u215D215D‰&amp;#8240\\u20302030%&amp;#37\\u00250025&lt;&amp;#60\\u003C003C&gt;&amp;#62\\u003E003E ♫&nbsp;&nbsp;音乐符号类&lt;table class=”zfz_table “cellpadding=”8”cellspacing=”0”&gt;符号UNICODE符号&lt;th colspan=”3”class=”lasttd”&gt;UNICODEHTMLJSCSSHTMLJSCSS♩&amp;#9833\\u26692669♪&amp;#9834\\u266A266A♫&amp;#9835\\u266B266B♬&amp;#9836\\u266C266C♭&amp;#9837\\u266D266D♯&amp;#9839\\u266F266F ✖&nbsp;&nbsp;对错号&lt;table class=”zfz_table “cellpadding=”8”cellspacing=”0”&gt;符号UNICODE符号&lt;th colspan=”3”class=”lasttd”&gt;UNICODEHTMLJSCSSHTMLJSCSS&nbsp;&amp;#160\\u00A000A0☐&amp;#9744\\u26102610☑&amp;#9745\\u26112611☒&amp;#9746\\u26122612✓&amp;#10003\\u27132713✔&amp;#10004\\u27142714✕&amp;#10005\\u1000510005✖&amp;#10006\\u27162716✗&amp;#10007\\u27172717✘&amp;#10008\\u27182718 ★&nbsp;&nbsp;全都是星星符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSS★&amp;#9733\\u26052605✭&amp;#10029\\u272D272D✮&amp;#10030\\u272E272E☆&amp;#9734\\u26062606✪&amp;#10026\\u272A272A✡&amp;#10017\\u27212721✯&amp;#10031\\u272F272F✵&amp;#10037\\u27352735✶&amp;#10038\\u27362736✸&amp;#10040\\u27382738✹&amp;#10041\\u27392739✺&amp;#10042\\u273A273A✱&amp;#10033\\u27312731✲&amp;#10034\\u27322732✴&amp;#10036\\u27342734✳&amp;#10035\\u27332733✻&amp;#10043\\u273B273B✽&amp;#10045\\u273D273D❋&amp;#10059\\u274B274B❆&amp;#10054\\u27462746❄&amp;#10052\\u27442744❅&amp;#10053\\u27452745 ♒&nbsp;&nbsp;星座类符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSS♈&amp;#9800\\u26482648♉&amp;#9801\\u26492649♊&amp;#9802\\u264A264A♋&amp;#9803\\u264B264B♌&amp;#9804\\u264C264C♍&amp;#9805\\u264D264D♎&amp;#9806\\u264E264E♏&amp;#9807\\u264F264F♐&amp;#9808\\u26502650♑&amp;#9809\\u26512651♒&amp;#9810\\u26522652♓&amp;#9811\\u26532653 ♚&nbsp;&nbsp;国际象棋类符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSS♚&amp;#9818\\u265A265A♛&amp;#9819\\u265B265B♜&amp;#9820\\u265C265C♝&amp;#9821\\u265D265D♞&amp;#9822\\u265E265E♟&amp;#9823\\u265F265F♔&amp;#9812\\u26542654♕&amp;#9813\\u26552655♖&amp;#9814\\u26562656♗&amp;#9815\\u26572657♘&amp;#9816\\u26582658♙&amp;#9817\\u26592659 ♣&nbsp;&nbsp;扑克牌类符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSS♠&amp;#9824\\u26602660♣&amp;#9827\\u26632663♥&amp;#9829\\u26652665♦&amp;#9830\\u26662666♤&amp;#9828\\u26642664♧&amp;#9831\\u26672667♡&amp;#9825\\u26612661♢&amp;#9826\\u26622662 Ω&nbsp;&nbsp;希腊字母符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSSΑ&amp;#913\\u03910391Β&amp;#914\\u03920392Γ&amp;#915\\u03930393Δ&amp;#916\\u03940394Ε&amp;#917\\u03950395Ζ&amp;#918\\u03960396Η&amp;#919\\u03970397Θ&amp;#920\\u03980398Ι&amp;#921\\u03990399Κ&amp;#922\\u039A039AΛ&amp;#923\\u039B039BΜ&amp;#924\\u039C039CΝ&amp;#925\\u039D039DΞ&amp;#926\\u039E039EΟ&amp;#927\\u039F039FΠ&amp;#928\\u03A003A0Ρ&amp;#929\\u03A103A1Σ&amp;#931\\u03A303A3Τ&amp;#932\\u03A403A4Υ&amp;#933\\u03A503A5Φ&amp;#934\\u03A603A6Χ&amp;#935\\u03A703A7Ψ&amp;#936\\u03A803A8Ω&amp;#937\\u03A903A9 ☩&nbsp;&nbsp;十字符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSS☨&amp;#9768\\u26282628☩&amp;#9769\\u26292629✝&amp;#10013\\u271D271D✞&amp;#10014\\u271E271E✟&amp;#10015\\u271F271F✠&amp;#10016\\u27202720✚&amp;#10010\\u271A271A†&amp;#8224\\u20202020✢&amp;#10018\\u27222722✤&amp;#10020\\u27242724✣&amp;#10019\\u27232723✥&amp;#10021\\u27252725 ©&nbsp;&nbsp;法律符号符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSS®&amp;#174\\u00AE00AE©&amp;#169\\u00A900A9℗&amp;#8471\\u21172117™&amp;#153\\u00990099℠&amp;#8480\\u21202120&nbsp;&nbsp;&nbsp;&nbsp; @&nbsp;&nbsp;标点和符号符号UNICODE符号UNICODEHTMLJSCSSHTMLJSCSS«&amp;#171\\u00AB00AB»&amp;#187\\u00BB00BB‹&amp;#139\\u008B008B›&amp;#155\\u009B009B“&amp;#8220\\u201C201C”&amp;#8221\\u201D201D‘&amp;#8216\\u20182018’&amp;#8217\\u20192019•&amp;#8226\\u20222022◦&amp;#9702\\u25E625E6¡&amp;#161\\u00A100A1¿&amp;#191\\u00BF00BF℅&amp;#8453\\u21052105№&amp;#8470\\u21162116&amp;&amp;#38\\u00260026@&amp;#64\\u00400040℞&amp;#8478\\u211E211E℃&amp;#8451\\u21032103℉&amp;#8457\\u21092109°&amp;#176\\u00B000B0|&amp;#124\\u007C007C¦&amp;#166\\u00A600A6–&amp;#8211\\u20132013—&amp;#8212\\u20142014…&amp;#8230\\u20262026¶&amp;#182\\u00B600B6&#8764;&amp;#8764\\u223C223C≠&amp;#8800\\u22602260总结归类：1.特色的©&amp;copy;©版权标志|&nbsp;|竖线，常用作菜单或导航中的分隔符·&amp;middot;·圆点，有时被用来作为菜单分隔符↑&amp;uarr;↑上箭头，常用作网页“返回页面顶部”标识€&amp;euro;€欧元标识²&amp;sup2;²上标2，数学中的平方，在数字处理中常用到，例如：1000²½&amp;frac12;½二分之一♥&amp;hearts;♥心型，用来表达你的心2常用的&nbsp;&amp;nbsp;&nbsp;空&#26684;&amp;&amp;amp;&amp;and符号，与“&amp;quot;“引号©&amp;copy;©版权标志®&amp;reg;»注册标志™&amp;trade;™商标标志“&amp;ldquo;“左双引号”&amp;rdquo;”右双引号‘&amp;lsquo;‘做单引号’&amp;rsquo;’右单引号«&amp;laquo;«左三角双引号»&amp;raquo;»右三角双引号‹&amp;lsaquo;‹左三角单引号›&amp;rsaquo;›右三角单引号§&amp;sect;§章节标志¶&amp;para;¶段落标志•&amp;bull;•列表圆点（大）·&amp;middot;·列表圆点（中）…&amp;hellip;…省略号|&nbsp;|竖线¦&amp;brvbar;¦断的竖线–&amp;ndash;–短破折号—&amp;mdash;—长破折号3.货币类¤&amp;curren;¤一般货币符号$&nbsp;$美元符号¢&amp;cent;¢分£&amp;pound;£英镑¥&amp;yen;¥日元€&amp;euro;€欧元4 数学类&lt;&amp;lt;&lt;小于号&gt;&amp;gt;&gt;大于号≤&amp;le;≤小于等于号≥&amp;ge;≥大于等于号×&amp;times;×乘号÷&amp;divide;÷除号−&amp;minus;−减号±&amp;plusmn;±加/减 号≠&amp;ne;≠不等于号¹&amp;sup1;¹上标1²&amp;sup2;²上标2³&amp;sup3;³上标3½&amp;frac12;½二分之一¼&amp;frac14;¼四分之一¾&amp;frac34;¾四分之三‰&amp;permil;‰千分率°&amp;deg;°度√&amp;radic;√平方根∞&amp;infin;∞无限大5.方向类←&amp;larr;←左箭头↑&amp;uarr;↑上箭头→&amp;rarr;→右箭头↓&amp;darr;↓下箭头↔&amp;harr;↔左右箭头↵&amp;crarr;↵回车箭头⌈&amp;lceil;⌈左上限⌉&amp;rceil;⌉右上限⌊&amp;lfloor;⌊左下限⌋&amp;rfloor;⌋右下限6&nbsp;其它♠&amp;spades;♠黑桃♣&amp;clubs;♣梅花♥&amp;hearts;♥红桃，心♦&amp;diams;♦方块牌◊&amp;loz;◊菱形†&amp;dagger;†匕首‡&amp;Dagger;‡双剑号¡&amp;iexcl;¡反向感叹号¿&amp;iquest;¿反向问号原文：http://zhengmifan.com/news/notebook/801 参考： http://114.xixik.com/character/ http://www.gzui.net/465 http://zhengmifan.com/news/notebook/801","categories":[{"name":"html","slug":"html","permalink":"http://007sair.github.io/categories/html/"}],"tags":[{"name":"unicode","slug":"unicode","permalink":"http://007sair.github.io/tags/unicode/"}]},{"title":"Javascript Tricks","slug":"js-tricks","date":"2016-06-21T16:00:00.000Z","updated":"2018-07-26T07:08:26.516Z","comments":true,"path":"2016/06/22/js-tricks/","link":"","permalink":"http://007sair.github.io/2016/06/22/js-tricks/","excerpt":"在这篇文章中将整理一些平时用到的js小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。 使用!!操作符转换布尔值有时候我们需要对一个变量检查其是否存在或者检查值是否有一个有效值，如果存在就返回true值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用!!variable做检测，只要变量的值为:0、null、&quot; &quot;、undefined或者NaN都将返回的是false，反之返回的是true。比如下面的示例： 1234567891011function Account(cash) &#123; this.cash = cash; this.hasMoney = !!cash;&#125;var account = new Account(100.50);console.log(account.cash); // 100.50console.log(account.hasMoney); // truevar emptyAccount = new Account(0);console.log(emptyAccount.cash); // 0console.log(emptyAccount.hasMoney); // false 在这个示例中，只要account.cash的值大于0，那么account.hasMoney返回的值就是true。","text":"在这篇文章中将整理一些平时用到的js小技巧。这些小技巧可能在你的实际工作中或许能帮助你解决一些问题。 使用!!操作符转换布尔值有时候我们需要对一个变量检查其是否存在或者检查值是否有一个有效值，如果存在就返回true值。为了做这样的验证，我们可以使用!!操作符来实现是非常的方便与简单。对于变量可以使用!!variable做检测，只要变量的值为:0、null、&quot; &quot;、undefined或者NaN都将返回的是false，反之返回的是true。比如下面的示例： 1234567891011function Account(cash) &#123; this.cash = cash; this.hasMoney = !!cash;&#125;var account = new Account(100.50);console.log(account.cash); // 100.50console.log(account.hasMoney); // truevar emptyAccount = new Account(0);console.log(emptyAccount.cash); // 0console.log(emptyAccount.hasMoney); // false 在这个示例中，只要account.cash的值大于0，那么account.hasMoney返回的值就是true。 使用+将字符串转换成数字这个技巧非常有用，其非常简单，可以交字符串数据转换成数字，不过其只适合用于字符串数据，否则将返回NaN，比如下面的示例： 12345function toNumber(strNumber) &#123; return +strNumber;&#125;console.log(toNumber(\"1234\")); // 1234console.log(toNumber(\"ACB\")); // NaN 这个也适用于Date，在本例中，它将返回的是时间戳数字： 1console.log(+new Date()) // 1466586198892 并条件符如果你有一段这样的代码： 123if (conected) &#123; login();&#125; 你也可以将变量简写，并且使用&amp;&amp;和函数连接在一起，比如上面的示例，可以简写成这样： 1conected &amp;&amp; login(); 如果一些属性或函数存在于一个对象中，你也可以这样做检测，如下面的代码所示： 1user &amp;&amp; user.login(); 使用||运算符在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用||操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为false，那么第二个值将会认为是一个默认值。如下面这个示例： 1234567891011function User(name, age) &#123; this.name = name || \"Oliver Queen\"; this.age = age || 27;&#125;var user1 = new User();console.log(user1.name); // Oliver Queenconsole.log(user1.age); // 27var user2 = new User(\"Barry Allen\", 25);console.log(user2.name); // Barry Allenconsole.log(user2.age); // 25 在循环中缓存array.length这个技巧很简单，这个在处理一个很大的数组循环时，对性能影响将是非常大的。基本上，大家都会写一个这样的同步迭代的数组： 123for(var i = 0; i &lt; array.length; i++) &#123; console.log(array[i]);&#125; 如果是一个小型数组，这样做很好，如果你要处理的是一个大的数组，这段代码在每次迭代都将会重新计算数组的大小，这将会导致一些延误。为了避免这种现象出现，可以将array.length做一个缓存： 1234var len = array.length;for(var i = 0; i &lt; len; i++) &#123; console.log(array[i]);&#125; 或者，这么写： 123for(var i = 0, len = array.length; i &lt; len; i++) &#123; console.log(array[i]);&#125; 检测对象中属性当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用document.querySelector()来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例： 12345678910if ('querySelector' in document) &#123; document.querySelector(\"#id\");&#125; else &#123; document.getElementById(\"id\");&#125;var oEvent = &#123; start : \"ontouchstart\" in document ? 'touchstart' : 'mousedown', end : \"ontouchend\" in document ? 'touchend' : 'mouseup'&#125;; 在这个示例中，如果document不存在querySelector函数，那么就会调用docuemnt.getElementById(&quot;id&quot;)。 如果document有ontouchstart属性（或函数），使用touchstart，否则使用mousedown 获取数组中最后一个元素Array.prototype.slice(begin, end)用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如： 1234var array = [1,2,3,4,5,6];console.log(array.slice(-1)); // [6]console.log(array.slice(-2)); // [5,6]console.log(array.slice(-3)); // [4,5,6] 复制数组复制数组有三种方法： 通过Array.prototype.slice()方法，该方法因为不对原数组进行操作，可以通过传入参数0或者不传的方式复制； 通过Array.prototype.concat()方法，该方法通过不传参来实现数组的合并以实现复制； 最笨的方法，循环遍历老数组，再一个个push到新数组中； 12345678910111213141516//方法1：var arr = [3,2,1], newArr;newArr = arr.slice();//方法2：var arr = [3,2,1], newArr;newArr = arr.concat();//方法3：var arr = [3,2,1]; newArr = [];for(var i = 0, len = arr.length; i &lt; len; i++) &#123; newArr.push(arr[i])&#125; 测试是否是新数组可以使用arr.sort()后，检测新数组是否也被排序。 数组截断这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length = 5来截断数组。如下面这个示例： 12345var array = [1,2,3,4,5,6];console.log(array.length); // 6array.length = 3;console.log(array.length); // 3console.log(array); // [1,2,3] 替换所有String.replace()函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll()函数功能： 123var string = \"john john\";console.log(string.replace(/hn/, \"ana\")); // \"joana john\"console.log(string.replace(/hn/g, \"ana\")); // \"joana joana\" 合并数组如果你要合并两个数组，一般情况之下你都会使用concat()函数： 123var array1 = [1,2,3];var array2 = [4,5,6];console.log(array1.concat(array2)); // [1,2,3,4,5,6]; 将NodeList或arguments转换成数组如果你运行document.querySelectorAll(&#39;p&#39;)函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort()、reduce()、map()、filter()等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用[].slice.call(elements)来实现： 123var elements = document.querySelectorAll(\"p\"); // NodeListvar arrayElements = [].slice.call(elements); // Now the NodeList is an arrayvar arrayElements = Array.from(elements); // This is another way of converting NodeList to Array 另外一个更有说服力的例子就是函数的arguments 12345678//检测arguments是否为数组function testargs()&#123; var arr=[1,2,3]; console.log(typeof arguments.slice); console.log(typeof arr.slice); console.log(arguments.constructor == Array.constructor, arr.constructor)&#125;testargs(); 输出： 123undefinedfunctionfalse Array() &#123; [native code] &#125; 如何转换arguments？ 12345function arg2arr()&#123; var arr = Array.prototype.slice.call(arguments); // or [].slice.call(arguments, 0) console.log(arr);&#125;arg2arr(1,2,3); //[1, 2, 3] 数组元素的洗牌对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做： 123456var list = [1,2,3];var result = list.sort(function() &#123; return Math.random() - 0.5 &#125;)console.log(result); // [2,1,3] 转自：http://www.w3cplus.com/javascript/12-extremely-useful-hacks-for-javascript.html","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"技巧","slug":"技巧","permalink":"http://007sair.github.io/tags/技巧/"}]},{"title":"web动画新选择：requestAnimationFrame","slug":"js-raf","date":"2016-03-27T16:00:00.000Z","updated":"2018-07-26T07:08:26.515Z","comments":true,"path":"2016/03/28/js-raf/","link":"","permalink":"http://007sair.github.io/2016/03/28/js-raf/","excerpt":"作者：If you’ve never written code to animate inside the browser, you can stop reading :) requestAnimationFrame是什么？在浏览器中，我们通常使用一个定时器（setInterval &amp; setTimeout）来循环每隔几毫秒移动目标物体一次，来让它动起来。 如今有一个好消息，浏览器开发商们决定：“嗨，为什么我们不在浏览器里提供这样一个API呢，这样一来我们可以为用户优化他们的动画。”所以，这个requestAnimationFrame()函数就是针对动画效果的API，你可以把它用在DOM上的风格变化或canvas或webGL中。 为什么我们要用它？ 浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。 另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。","text":"作者：If you’ve never written code to animate inside the browser, you can stop reading :) requestAnimationFrame是什么？在浏览器中，我们通常使用一个定时器（setInterval &amp; setTimeout）来循环每隔几毫秒移动目标物体一次，来让它动起来。 如今有一个好消息，浏览器开发商们决定：“嗨，为什么我们不在浏览器里提供这样一个API呢，这样一来我们可以为用户优化他们的动画。”所以，这个requestAnimationFrame()函数就是针对动画效果的API，你可以把它用在DOM上的风格变化或canvas或webGL中。 为什么我们要用它？ 浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果。比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。 另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量。 和setTimeout、setInterval的区别 setInterval、setTimeout是开发者主动要求浏览器去绘制，但是由于种种问题，浏览器可能会漏掉部分命令 requestAnimationFrame 就是浏览器什么要开始绘制了浏览器自己知道，通过requestAnimationFrame 告诉开发者，这样就不会出现重复绘制丢失的问题了 requestAnimationFrame的用法1234567891011121314151617181920//向下兼容，使用setTimeoutwindow.requestAnimFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function( callback )&#123; window.setTimeout(callback, 1000 / 60); &#125;;&#125;)();// usage:// instead of setInterval(render, 16) ....(function animloop()&#123; requestAnimFrame(animloop); render();&#125;)();// place the rAF *before* the render() to assure as close to// 60fps with the setTimeout fallback. Opera浏览器的技术师Erik Möller 把这个函数进行了封装，使得它能更好的兼容各种浏览器。但基本上他的代码就是判断使用4ms还是16ms的延迟，来最佳匹配60fps。下面就是这段代码，你可以使用它，但请注意，这段代码里使用的是标准函数，我给它加上了cancel*方法和兼容各种浏览器引擎前缀。 123456789101112131415161718192021222324(function() &#123; var lastTime = 0; var vendors = ['ms', 'moz', 'webkit', 'o']; for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) &#123; window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame']; &#125; if (!window.requestAnimationFrame) window.requestAnimationFrame = function(callback, element) &#123; var currTime = new Date().getTime(); var timeToCall = Math.max(0, 16 - (currTime - lastTime)); var id = window.setTimeout(function() &#123; callback(currTime + timeToCall); &#125;, timeToCall); lastTime = currTime + timeToCall; return id; &#125;; if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) &#123; clearTimeout(id); &#125;;&#125;()); 或者访问作者在Gist上的源码 让我们看看效果 The requestAnimationFrame API12345window.requestAnimationFrame(function(/* time */ time)&#123; // time ~= +new Date // the unix time&#125;);//回调函数里的第一个参数可以传入时间。 关于兼容使用can i use查看 转自：http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"requestAnimationFrame","slug":"requestAnimationFrame","permalink":"http://007sair.github.io/tags/requestAnimationFrame/"}]},{"title":"移动web开发笔记","slug":"h5-web-keng","date":"2016-02-28T16:00:00.000Z","updated":"2018-07-26T07:08:26.515Z","comments":true,"path":"2016/02/29/h5-web-keng/","link":"","permalink":"http://007sair.github.io/2016/02/29/h5-web-keng/","excerpt":"dd{ margin-left: 1em; } dd:before{ content: '·'; font-weight: bold; margin-right: 0.5em; } Meta标签1234567891011&lt;!--让页面强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览。--&gt;&lt;meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;\" name=\"viewport\" /&gt;&lt;!--是否添加至主屏幕的页面允许全屏模式浏览；--&gt;&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\" /&gt;&lt;!--指定的iphone中safari顶端的状态条的样式；--&gt;&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\" /&gt;&lt;!--关闭数字自动识别为电话号码--&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt; 触摸并按住触摸目标时候，禁止或显示系统默认菜单在iOS上，当你触摸并按住触摸的目标，比如一个链接，Safari浏览器将显示链接有关的系统默认菜单。这个属性可以让你禁用系统默认菜单。参考自：http://www.css88.com/book/css/webkit/behavior/touch-callout.htm 123div &#123; -webkit-touch-callout: none&#125;","text":"dd{ margin-left: 1em; } dd:before{ content: '·'; font-weight: bold; margin-right: 0.5em; } Meta标签1234567891011&lt;!--让页面强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览。--&gt;&lt;meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;\" name=\"viewport\" /&gt;&lt;!--是否添加至主屏幕的页面允许全屏模式浏览；--&gt;&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\" /&gt;&lt;!--指定的iphone中safari顶端的状态条的样式；--&gt;&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\" /&gt;&lt;!--关闭数字自动识别为电话号码--&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\" /&gt; 触摸并按住触摸目标时候，禁止或显示系统默认菜单在iOS上，当你触摸并按住触摸的目标，比如一个链接，Safari浏览器将显示链接有关的系统默认菜单。这个属性可以让你禁用系统默认菜单。参考自：http://www.css88.com/book/css/webkit/behavior/touch-callout.htm 123div &#123; -webkit-touch-callout: none&#125; 禁止用户选中文字1234p&#123; -webkit-user-select:none; user-select:none&#125; 可参考：http://www.css88.com/book/css/properties/user-interface/user-select.htm 使用特殊链接如果你关闭自动识别后 ，又希望某些电话号码能够链接到 iPhone 的拨号功能 ，那么可以通过这样来声明电话链接， 123&lt;a href=\"tel:12345654321\"&gt;打电话给我&lt;/a&gt;&lt;a href=\"sms:12345654321\"&gt;发短信&lt;/a&gt;&lt;a href=\"mailto:longsair@gmail.com\"&gt;longsair@gmail.com&lt;/a&gt; 或用于单元格： 1&lt;td onclick=\"location.href='tel:122'\"&gt;&lt;/td&gt; 去除URL的控件条1setTimeout(scrollTo,0,0,0); 获取滚动条的值pc端获取浏览器的滚动条是通过document.scrollTop&amp;document.scrollLeft，但在ios中这两个值是未定义的，因为ios中没有滚动条的概念，Android中通过这两个属性可以正常获取到滚动条的值，那么在iOS中我们该如何获取滚动条的值呢？就是上面两个属性，但是事实证明android也支持这属性，所以索性都用： 1window.scrollY window.scrollX Reset Styles123456789101112131415161718192021222324252627282930313233343536373839404142434445body &#123; font-family: \"Helvetica Neue\", Helvetica, STHeiTi, sans-serif; /* 使用无衬线字体 */&#125;a, img &#123; -webkit-touch-callout: none; /* 禁止长按链接与图片弹出菜单 */&#125;html, body &#123; -webkit-user-select: none; /* 禁止选中文本 */ user-select: none;&#125;button,input,optgroup,select,textarea &#123; -webkit-appearance:none; /* 去掉webkit默认的表单样式 */&#125;a,button,input,optgroup,select,textarea &#123; -webkit-tap-highlight-color:rgba(0,0,0,0); /* 去掉a、input和button点击时的蓝色外边框和灰色半透明背景 */&#125;body &#123; -webkit-text-size-adjust: none; /* 禁止IOS调整字体大小 */&#125;input::-webkit-input-speech-button &#123; display: none; /* 隐藏Android的语音输入按钮 */&#125;img&#123; -webkit-touch-calloutt:none; /* iOS中如何禁止用户保存图片 复制图片 */&#125;/* * input placeholder */input::-webkit-input-placeholder &#123; color: #999; /* WebKit browsers */ &#125; input:-moz-placeholder &#123; color: #999; /* Mozilla Firefox 4 to 18 */&#125; input::-moz-placeholder &#123; color: #999; /* Mozilla Firefox 19+ */&#125; input:-ms-input-placeholder &#123; color: #999; /* Internet Explorer 10+ */&#125;input:focus::-webkit-input-placeholder&#123; opacity: 0; /* 设置placeholder时候 focus时候文字没有隐藏 */&#125; h5搜索键盘经测试发现需要一下组合，可以使呼起的键盘具有“搜索”或“前往”字样。 &lt;form&gt; 标签需要具有action属性 &lt;input&gt; 标签需要设置type=&quot;search&quot; 如下： 1&lt;form action=\"#\"&gt; &lt;input type=\"search\" /&gt; &lt;/form&gt; 另外，如果要移除搜索框的叉叉图标，可以设置样式::-webkit-search-cancel-button { display: none; } 横屏 &amp; 竖屏事件：window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式； 1234567891011window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert(\"横屏:\" + window.orientation); case 0: case 180: alert(\"竖屏:\" + window.orientation); break; &#125;&#125; 样式： 12345678910111213141516//竖屏时使用的样式&lt;style media=\"all and (orientation:portrait)\" type=\"text/css\"&gt;#landscape &#123; display: none; &#125;&lt;/style&gt;@media all and (orientation:portrait) &#123; .css&#123;&#125;&#125;//横屏时使用的样式&lt;style media=\"all and (orientation:landscape)\" type=\"text/css\"&gt;#portrait &#123; display: none; &#125;&lt;/style&gt; @media all and (orientation:landscape) &#123; .css&#123;&#125;&#125; audio &amp; vedio在ios端自动播放1234567891011var oAudio = new Audio('shake.mp3');var isAudio = false;var fixaudio = function() &#123; if (!isAudio) &#123; isAudio = true; oAudio.play(); oAudio.pause(); //这个例子因为是一个摇一摇的背景音乐，不是加载后立即播放，所以用了`oAudio.pause()` document.removeEventListener('touchstart', fixaudio, false); &#125;&#125;;document.addEventListener('touchstart', fixaudio, false); 具体讨论参考：http://www.cnblogs.com/PeunZhang/archive/2013/02/05/2893093.html 自动大写与自动修正要关闭这两项功能，可以通过autocapitalize 与autocorrect 这两个选项： 1&lt;input type=\"text\" autocapitalize=\"off\" autocorrect=\"off\" /&gt; 文件上传, 从相机捕获媒体123&lt;input type=\"file\" accept = \"image/*; capture=camera\" /&gt;&lt;input type=\"file\" accept = \"video/*; capture=camcorder\" /&gt;&lt;input type=\"file\" accept = \"audio/*; capture=microphone\" /&gt; 使用总结： : ios 有拍照、录像、选取本地图片功能 : 部分android只有选取本地图片功能 : winphone不支持 : input控件默认外观丑陋 基于css的原生滚动12345678ul &#123; overflow: auto; -webkit-overflow-scrolling: touch;&#125;ul::-webkit-scrollbar &#123; /* 隐藏滚动条 */ opacity: 0; display: none;&#125; 消除transition闪屏123456div &#123; /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden;&#125; 播放视频不全屏12345678&lt;!-- 1.目前只有ios7+、winphone8+支持自动播放 2.支持Airplay的设备（如：音箱、Apple TV)播放 x-webkit-airplay=\"true\" 3.播放视频不全屏，ios7+、winphone8+支持，部分android4+支持（含华为、小米、魅族） webkit-playsinline=\"true\" --&gt;&lt;video x-webkit-airplay=\"true\" webkit-playsinline=\"true\" preload=\"auto\" autoplay src=\"http://\"&gt;&lt;/video&gt; 滑屏框架 slip.js iSlider fullpage swiper 模拟:hover伪类因为iPhone并没有鼠标指针，所以没有hover事件。那么CSS :hover伪类就没用了。但是iPhone有Touch事件，onTouchStart 类似 onMouseOver，onTouchEnd 类似 onMouseOut。所以我们可以用它来模拟hover。使用Javascript： 12345var myLinks = document.getElementsByTagName('a');for(var i = 0; i &lt; myLinks.length; i++)&#123; myLinks[i].addEventListener(’touchstart’, function()&#123;this.className = “hover”;&#125;, false); myLinks[i].addEventListener(’touchend’, function()&#123;this.className = “”;&#125;, false);&#125; 然后用CSS增加hover效果： 1a:hover, a.hover &#123; /* 你的hover效果 */ &#125; 这样设计一个链接，感觉可以更像按钮。并且，这个模拟可以用在任何元素上。 判断设备类型12345678910111213141516171819202122232425262728293031323334//方法一：function browserRedirect() &#123; var ua = navigator.userAgent.toLowerCase(); var bIsIpad = ua.match(/ipad/i) == \"ipad\"; var bIsIphoneOs = ua.match(/iphone os/i) == \"iphone os\"; var bIsMidp = ua.match(/midp/i) == \"midp\"; var bIsUc7 = ua.match(/rv:1.2.3.4/i) == \"rv:1.2.3.4\"; var bIsUc = ua.match(/ucweb/i) == \"ucweb\"; var bIsAndroid = ua.match(/android/i) == \"android\"; var bIsCE = ua.match(/windows ce/i) == \"windows ce\"; var bIsWM = ua.match(/windows mobile/i) == \"windows mobile\"; console.log(\"您的浏览设备为：\"); if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) &#123; console.log(\"phone\"); &#125; else &#123; console.log(\"pc\"); &#125;&#125;//方法二：var deviceAgent = navigator.userAgent.toLowerCase();var agentID = deviceAgent.match(/(iphone|ipod|ipad|android)/);if (agentID.indexOf(\"iphone\") &gt;= 0) &#123; alert(\"iphone\");&#125;if (agentID.indexOf(\"ipod\") &gt;= 0) &#123; alert(\"ipod\");&#125;if (agentID.indexOf(\"ipad\") &gt;= 0) &#123; alert(\"ipad\");&#125;if (agentID.indexOf(\"android\") &gt;= 0) &#123; alert(\"android\");&#125; flex属性假设flex容器为.box ，子元素为.item，兼容性自行添加 1、定义容器为flex的布局 12345678910111213141516171819202122232425262728293031323334.box&#123; display: -webkit-flex; /*webkit*/ display: flex;&#125;/*行内flex*/.box&#123; display: -webkit-inline-flex; /*webkit*/ display:inline-flex;&#125;``` 2、定义父容器```css.box&#123; flex-direction: row | row-reverse | column | column-reverse; /*主轴方向：左到右（默认） | 右到左 | 上到下 | 下到上*/ flex-wrap: nowrap | wrap | wrap-reverse; /*换行：不换行（默认） | 换行 | 换行并第一行在下方*/ flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; /*主轴方向和换行简写*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ align-content: flex-start | flex-end | center | space-between | space-around | stretch; /*多主轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布*/&#125; 3、子元素 12345678910111213141516171819.item&#123; order: &lt;integer&gt;; /*排序：数值越小，越排前，默认为0*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ flex-basis: &lt;length&gt; | auto; /* default auto */ /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/ flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/ align-self: auto | flex-start | flex-end | center | baseline | stretch; /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/&#125;","categories":[{"name":"web","slug":"web","permalink":"http://007sair.github.io/categories/web/"}],"tags":[{"name":"坑","slug":"坑","permalink":"http://007sair.github.io/tags/坑/"},{"name":"web","slug":"web","permalink":"http://007sair.github.io/tags/web/"}]},{"title":"SASS编译中文出现错误的解决方法","slug":"sass-note","date":"2016-01-11T16:00:00.000Z","updated":"2018-07-26T07:08:26.514Z","comments":true,"path":"2016/01/12/sass-note/","link":"","permalink":"http://007sair.github.io/2016/01/12/sass-note/","excerpt":"背景sass文件编译时候使用ruby环境，在使用koala或者命令行时，会因为中文注释产生如下错误： 1234Syntax error: Invalid GBK character &quot;\\xE5&quot; on line 8 of E:\\work\\sass\\sass\\_big_box.scss from line 16 of E:\\work\\sass\\sass\\main.scss Use --trace for backtrace. or： 123Syntax error: Invalid GBK character &quot;\\xE5&quot; on line 2 of E:\\work\\sass\\sass\\main.scss Use --trace for backtrace. 解决方法koala可视化编译工具找到安装目录里面sass-3.3.7模块下面的engine.rb文件，例如下面路径： C:\\Program Files (x86)\\Koala\\rubygems\\gems\\sass-3.3.7\\lib\\sass 在这个文件里面engine.rb，添加一行代码1Encoding.default_external = Encoding.find(&apos;utf-8&apos;) 放在所有的require XXXX 之后即可。","text":"背景sass文件编译时候使用ruby环境，在使用koala或者命令行时，会因为中文注释产生如下错误： 1234Syntax error: Invalid GBK character &quot;\\xE5&quot; on line 8 of E:\\work\\sass\\sass\\_big_box.scss from line 16 of E:\\work\\sass\\sass\\main.scss Use --trace for backtrace. or： 123Syntax error: Invalid GBK character &quot;\\xE5&quot; on line 2 of E:\\work\\sass\\sass\\main.scss Use --trace for backtrace. 解决方法koala可视化编译工具找到安装目录里面sass-3.3.7模块下面的engine.rb文件，例如下面路径： C:\\Program Files (x86)\\Koala\\rubygems\\gems\\sass-3.3.7\\lib\\sass 在这个文件里面engine.rb，添加一行代码1Encoding.default_external = Encoding.find(&apos;utf-8&apos;) 放在所有的require XXXX 之后即可。 命令行工具同理找到ruby的安装目录，里面也有sass模块，如这个路径： 1C:\\Ruby\\lib\\ruby\\gems\\1.9.1\\gems\\sass-3.3.14\\lib\\sass 在这个文件里面engine.rb，添加一行代码（同方法1） Encoding.default_external = Encoding.find(‘utf-8’) 放在所有的require XXXX 之后即可。 转自：http://www.itnose.net/detail/6089821.html","categories":[{"name":"sass","slug":"sass","permalink":"http://007sair.github.io/categories/sass/"}],"tags":[{"name":"坑","slug":"坑","permalink":"http://007sair.github.io/tags/坑/"},{"name":"sass","slug":"sass","permalink":"http://007sair.github.io/tags/sass/"}]},{"title":"Web 开发中 20 个很有用的 CSS 库","slug":"css-library","date":"2015-10-31T16:00:00.000Z","updated":"2018-07-26T07:08:26.514Z","comments":true,"path":"2015/11/01/css-library/","link":"","permalink":"http://007sair.github.io/2015/11/01/css-library/","excerpt":"在过去的几年中，CSS已经成为一大部分开发者和设计者的最爱，因为它提供了一系列功能和特性。每个月都有无数个围绕CSS的工具被开发者发布以简化WEB开发。像CSS 库，框架，应用这样的工具能够为开发者做很多事，而且可以使开发者创造出创新立异的WEB应用。 在这篇文件章中我们找到了一系列对开发者有用的CSS库，它们能帮助开发者在一定的期限内取得有创造性和创新性的成果。我们希望这个列表能有助于您的开发并为您提供方便。尽情享受吧！ Kite Kite是一个灵活的布局助手CSS库。Kite使用inline-block而不是最新的CSS语法。它注重实际，易于理解且容易使用。Kite用法与flexbox相似：justify-content,等等。你可以很轻松地创建复杂的模块。Kite是基于OOCSS 与 MindBEMding，它可以帮助您快速构建自己的组件。Kite支持几乎所有浏览器，它属于MIT许可。","text":"在过去的几年中，CSS已经成为一大部分开发者和设计者的最爱，因为它提供了一系列功能和特性。每个月都有无数个围绕CSS的工具被开发者发布以简化WEB开发。像CSS 库，框架，应用这样的工具能够为开发者做很多事，而且可以使开发者创造出创新立异的WEB应用。 在这篇文件章中我们找到了一系列对开发者有用的CSS库，它们能帮助开发者在一定的期限内取得有创造性和创新性的成果。我们希望这个列表能有助于您的开发并为您提供方便。尽情享受吧！ Kite Kite是一个灵活的布局助手CSS库。Kite使用inline-block而不是最新的CSS语法。它注重实际，易于理解且容易使用。Kite用法与flexbox相似：justify-content,等等。你可以很轻松地创建复杂的模块。Kite是基于OOCSS 与 MindBEMding，它可以帮助您快速构建自己的组件。Kite支持几乎所有浏览器，它属于MIT许可。 DynCSS DynCSS 将您的CSS解析成-dyn-(attribute)规则。这些规则是模拟浏览器事件(如滚动和缩放)的javascript表达式。其结果会应用到上面指出的CSS属性。你可以将任何CSS属性设置为动态–前提是它对于jQuery的css()方法是可写的。你可以通过附加-dyn-前缀并指定一个引用的javascript表达式来实现。 Progressjs ProgressJs 是一个 JavaScript 和CSS3库，可以帮助开发者创建和管理页面上所有元素的进度。你可以设计自己的进度条模板并且可以轻松自定义它。你也可以用ProgressJs 来为用户显示内容加载（图片，视频等）的进度。它可以用在textbox，textarea 甚至整个body上。 Hover.CSS Hover.CSS 是一个有用的CSS3悬停效果集合，可用于动作调用，按钮，商标，特性图片等。 自定或直接应用到你自己的元素上都非常的简单。 hover.css可以用多种方式来使用; 可以复制粘贴你喜欢的效果到你自己的样式表里，也可以引用样式表。然后只需向你想要的元素需添加对应效果的class名称即可。如果你只打算使用一个或几个效果，最佳实践是复制粘贴一个效果。 Spinkit Spin kit是一个酷炫的加载动画CSS集合。 Spinkit使用CSS动画来创建吸引人的易于自定义的动画。该集合目标不是提供所有浏览器的解决方案–如果你需要支持哪些还没实现CSS动画属性（像是IE9及之前的版本）的浏览器，你需要检测下这些动画属性并实现一个变通方案。 Magic CSS3 Animation Magic CSS3 Animations 是一个特殊效果的CSS3动画库，你可以免费用于你的web项目。简单的引用CSS样式：magic.css或精简版magic.min.css即可。 Bounce.js Bounce.js是一个用来生成不错的CSS3驱动关键帧动画的工具。用于生成动态动画的JS库是在该工具中投入使用。简单地添加一个组件，选择预设，然后你就会得到一个短URL地址或者导出到CSS。 ImaCSS Imacss是用来将图像文件转换为数据地址的库和应用。该地址可以用来插入到CSS文件中作为背景图片。本质上来讲，它能让你减少所有你对你设计的图片（如图标等）的HTTP请求，并使之能够单个调用。 Buttons Buttons是一个可以创建高度自定义、灵活和现代感十足的web按钮的CSS库。该库由Sass+Compass构建，支持正方形、圆角矩形或者圆形的按钮，并且可选是否扁平以及其他自定义的效果（如发光）。所使用到的尺寸、颜色、效果和字体可以通过变量的帮助进行修改，并且可以非常容易的进行扩展。 OdoMeter OdeMeter是一个用来创建一些我们比较熟悉的如“汽车里程显示，机场信息板或角子机”等效果或者面板的JavaScript-CSS库。该库是独立式+轻量级（3kb）的，使用CSS为效果进行转换，所以效率极高（当然也有回退设置）。它简单地将一个给定的元素转换到另一个具有单行函数的预定义的值。 Single Element CSS Spinner Single Element CSS Spinners是一个CSS螺旋动画加载的集合。每个旋转包含一个使用‘loader’ class的div，其文本内容为‘Loading…’。文本是为屏幕阅读器使用的且可用作老浏览器的后退的状态。 Ani.js AniJS是一个CSS动画的声明处理库，它能够使开发更便利且能提高开发速度。它文档完善且易于上手。 Beautons Beautons是一个用来创建漂亮、简洁按钮的易用库。你可以应用各种样式、函数已经其他的更多内容到按键上，包括改变它们的大小，设置它们的可用与否以及更多设置。 typo.css typo.css 的目的是，在一致化浏览器排版效果的同时，构建最适合中文阅读的网页排版。本博客就是使用这个库。 CSS Shakes 这是一个能够震动和晃动‘DOM’的CSS类集合。 Typebase.css Typebase.css是个最小化的、可定制的字体样式表。它有less和SASS版本，所以能够很容易地修改融入现代的Web项目。它提供了所有排版所必要的基础工具且不需添加其他任何设计内容。它被创建用来完成项目发展和成长期时的修改，能和normalize.css很好的工作。 Sassline 在web上使用Sass &amp; rems设置文本到基线网格。Sassline可以用在博客、prototyping以及其他Web项目。它有建议的基础字体样式和混合比例已达到基线网格的良好配合。为每个断点选择一个modular-scale，其运行响应将会更好。 TypeSettings 一个Sass工具包，基于modular scale有Ems风格，纵向风格，响应比基于headlines。 Type Rendering Mix Type Rendering Mix是个小型的JavaScript库，它允许只有使用核心文本时（在iOS和OS X上）才应用样式，在实现更一致的渲染同时保持高精度原态。 Hint.css Hint.css是一个使用SASS构建只使用CSS和HTML的提示库。该库使用数据属性、内容属性、伪元素以及CSS3转换。提示框简洁漂亮，有箭头且可放置在父元素的任何一边。","categories":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"资源","slug":"资源","permalink":"http://007sair.github.io/tags/资源/"},{"name":"库","slug":"库","permalink":"http://007sair.github.io/tags/库/"}]},{"title":"Javascript常用排序和算法","slug":"js-bubble","date":"2015-10-26T16:00:00.000Z","updated":"2018-07-26T07:08:26.513Z","comments":true,"path":"2015/10/27/js-bubble/","link":"","permalink":"http://007sair.github.io/2015/10/27/js-bubble/","excerpt":"冒泡排序核心思想：每次比较相邻的两个值，若后面的值比前面的值小，则交换位置，重复此操作，直到数据从小到大排列看起来像水泡一样冒上去了！ 如何交换数据位置？使用临时变量123456789var a=15;var b=7;var tmp;tmp=a;a=b;b=tmp;console.log('a是:'+a+', b是:'+b);","text":"冒泡排序核心思想：每次比较相邻的两个值，若后面的值比前面的值小，则交换位置，重复此操作，直到数据从小到大排列看起来像水泡一样冒上去了！ 如何交换数据位置？使用临时变量123456789var a=15;var b=7;var tmp;tmp=a;a=b;b=tmp;console.log('a是:'+a+', b是:'+b); 求和再相减12345678var a=19;var b=10;b=a+b; //俩人的和先求出来，然后分别算减法就行a=b-a; //此时 b是总和 减去a其实就是b的结果b=b-a; //同理console.log('a是:'+a+', b是:'+b); 求和再相减2123456var a=19;var b=10;a=a+b-(b=a); //简写 其实本质还是求和 相减console.log('a是:'+a+', b是:'+b); 乘以0再对换123456var a=19;var b=10;b=a+(a=b)*0; //这个直接换 其实就是 b=a a=bconsole.log('a是:'+a+', b是:'+b); 相乘相除12345678var a=19;var b=10;a=a*b;b=a/b;a=a/b;console.log('a是:'+a+', b是:'+b); 逻辑运算符12345678var a=19;var b=10;a=a^b;b=a^b;a=a^b;console.log('a是:'+a+', b是:'+b); 完整的冒泡排序如下： 123456789101112131415var arr=[23,1,32,22,8,101,9,-100];function bubbleSort(arr)&#123; var tmp, len=arr.length; for(var i=0; i&lt;len-1; i++)&#123; for(var j=0; j&lt;len-1; j++)&#123; if(arr[j]&gt;arr[j+1])&#123; tmp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp; &#125; &#125; &#125; return arr;&#125;console.log(bubbleSort(arr)); 之所以要len-1，是因为，每次抓两个数比较，所以，最后那个数就不需要了… 选择排序实现原理：循环数组，每次从数组里面找到最小值，然后和当前的换位置，又是换位置 1234567891011121314151617var arr=[23,1,32,22,8,-1000,101,9,-100];function selectionSort(arr)&#123; for(var i=0; i&lt;arr.length; i++)&#123; var iMinIndex=i; for(var j=i+1; j&lt;arr.length; j++)&#123; if(arr[j]&lt;arr[iMinIndex])&#123; iMinIndex=j; &#125; &#125; var tmp; tmp=arr[i]; arr[i]=arr[iMinIndex]; arr[iMinIndex]=tmp; &#125; return arr;&#125;console.log(selectionSort(arr)); iMinIndex就是每次最小值的索引！over……… 当然还有很多，后续一一实现，比如插入排序，希尔排序，归并排序，快速排序等…..","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://007sair.github.io/tags/算法/"}]},{"title":"Javascript执行效率小结","slug":"js-execution-efficiency","date":"2015-10-19T16:00:00.000Z","updated":"2018-07-26T07:08:26.513Z","comments":true,"path":"2015/10/20/js-execution-efficiency/","link":"","permalink":"http://007sair.github.io/2015/10/20/js-execution-efficiency/","excerpt":"Javascript是一门非常灵活的语言，我们可以随心所欲的书写各种风格的代码，不同风格的代码也必然也会导致执行效率的差异，开发过程中零零散散地接触到许多提高代码性能的方法，整理一下平时比较常见并且容易规避的问题 JS自身执行效率Javascript中的作用域链、闭包、原型继承、eval等特性，在提供各种神奇功能的同时也带来了各种效率问题，用之不慎就会导致执行效率低下。","text":"Javascript是一门非常灵活的语言，我们可以随心所欲的书写各种风格的代码，不同风格的代码也必然也会导致执行效率的差异，开发过程中零零散散地接触到许多提高代码性能的方法，整理一下平时比较常见并且容易规避的问题 JS自身执行效率Javascript中的作用域链、闭包、原型继承、eval等特性，在提供各种神奇功能的同时也带来了各种效率问题，用之不慎就会导致执行效率低下。 1、全局导入我们在编码过程中多多少少会使用到一些全局变量（window,document,自定义全局变量等等），了解javascript作用域链的人都知道，在局部作用域中访问全局变量需要一层一层遍历整个作用域链直至顶级作用域，而局部变量的访问效率则会更快更高，因此在局部作用域中高频率使用一些全局对象时可以将其导入到局部作用域中，例如： 123456789101112//1、作为参数传入模块(function(window,$)&#123; var xxx = window.xxx; $(\"#xxx1\").xxx(); $(\"#xxx2\").xxx();&#125;)(window,jQuery);//2、暂存到局部变量function()&#123; var doc = document; var global = window.global;&#125; 2、eval以及类eval问题我们都知道eval可以将一段字符串当做js代码来执行处理，据说使用eval执行的代码比不使用eval的代码慢100倍以上（具体效率我没有测试，有兴趣同学可以测试一下） JavaScript 代码在执行前会进行类似“预编译”的操作：首先会创建一个当前执行环境下的活动对象，并将那些用 var 申明的变量设置为活动对象的属性，但是此时这些变量的赋值都是 undefined，并将那些以 function 定义的函数也添加为活动对象的属性，而且它们的值正是函数的定义。但是，如果你使用了eval，则eval中的代码（实际上为字符串）无法预先识别其上下文，无法被提前解析和优化，即无法进行预编译的操作。所以，其性能也会大幅度降低 其实现在大家一般都很少会用eval了，这里我想说的是两个类eval的场景(new Function{},setTimeout,setInterver) 12345setTimtout(\"alert(1)\",1000);setInterver(\"alert(1)\",1000);(new Function(\"alert(1)\"))(); 上述几种类型代码执行效率都会比较低，因此建议直接传入匿名方法、或者方法的引用给setTimeout方法。 3、闭包结束后释放掉不再被引用的变量1234567891011var f = (function()&#123; var a = &#123;name:\"var3\"&#125;; var b = [\"var1\",\"var2\"]; var c = document.getElementByTagName(\"li\"); //****其它变量 //***一些运算 var res = function()&#123; alert(a.name); &#125; return res;&#125;)() 上述代码中变量f的返回值是由一个立即执行函数构成的闭包中返回的方法res，该变量保留了对于这个闭包中所有变量（a,b,c等）的引用，因此这两个变量会一直驻留在内存空间中,尤其是对于dom元素的引用对内存的消耗会很大，而我们在res中只使用到了a变量的值，因此，在闭包返回前我们可以将其它变量释放。 12345678910111213var f = (function()&#123; var a = &#123;name:\"var3\"&#125;; var b = [\"var1\",\"var2\"]; var c = document.getElementByTagName(\"li\"); //****其它变量 //***一些运算 //闭包返回前释放掉不再使用的变量 b = c = null; var res = function()&#123; alert(a.name); &#125; return res;&#125;)() JS操作dom的效率在web开发过程中，前端执行效率的瓶颈往往都是在dom操作上面，dom操作是一件很耗性能的事情，如何才能在dom操作过程中尽量节约性能呢？ 1、减少reflow什么是reflow？ 当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint。 如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow。 减少reflow的方法 先将元素从document中删除，完成修改后再把元素放回原来的位置（当对某元素及其子元素进行大量reflow操作时，1,2两种方法效果才会比较明显）将元素的display设置为”none”，完成修改后再把display修改为原来的值修改多个样式属性时定义class类代替多次修改style属性（for certain同学推荐）大量添加元素到页面时使用documentFragment例如 12345for(var i=0;i&lt;100:i++)&#123;var child = docuemnt.createElement(\"li\");child.innerHtml = \"child\";document.getElementById(\"parent\").appendChild(child);&#125; 上述代码会多次操作dom，效率比较低，可以改为下面的形式 创建documentFragment，将所有元素加入到docuemntFragment不会改变dom结构，最后将其添加到页面，只进行了一次reflow。 1234567var frag = document.createDocumentFragment();for(var i=0;i&lt;100:i++)&#123; var child = docuemnt.createElement(\"li\"); child.innerHtml = \"child\"; frag.appendChild(child);&#125;document.getElementById(\"parent\").appendChild(frag); 2、暂存dom状态信息当代码中需要多次访问元素的状态信息，在状态不变的情况下我们可以将其暂存到变量中，这样可以避免多次访问dom带来内存的开销，典型的例子就是： 123456789ar lis = document.getElementByTagName(\"li\");for(var i=1;i&lt;lis.length;i++)&#123; //***&#125;上述方式会在每一次循环都去访问dom元素，我们可以简单将代码优化如下var lis = document.getElementByTagName(\"li\");for(var i=1,j=lis.length ;i&lt;j;i++)&#123; //***&#125; 3、缩小选择器的查找范围 查找dom元素时尽量避免大面积遍历页面元素，尽量使用精准选择器，或者指定上下文以缩小查找范围，以jquery为例 少用模糊匹配的选择器：例如$(&quot;[name*=&#39;_fix&#39;]&quot;)，多用诸如id以及逐步缩小范围的复合选择器$(&quot;li.active&quot;)等指定上下文：例如$(&quot;#parent .class&quot;)，$(&quot;.class&quot;, $el)等 4、使用事件委托使用场景：一个有大量记录的列表，每条记录都需要绑定点击事件，在鼠标点击后实现某些功能，我们通常的做法是给每条记录都绑定监听事件，这种做法会导致页面会有大量的事件监听器，效率比较低下。 基本原理：我们都知道dom规范中事件是会冒泡的，也就是说在不主动阻止事件冒泡的情况下任何一个元素的事件都会按照dom树的结构逐级冒泡至顶端。而event对象中也提供了event.target（IE下是srcElement）指向事件源，因此我们即使在父级元素上监听该事件也可以找到触发该事件的最原始的元素，这就是委托的基本原理。废话不多说，上示例 123$(\"ul li\").bind(\"click\",function()&#123; alert($(this).attr(\"data\"));&#125;) 上述写法其实是给所有的li元素都绑定了click事件来监听鼠标点击每一个元素的事件，这样页面上会有大量的事件监听器。 根据上面介绍的监听事件的原理我们来改写一下 12345$(\"ul\").bind(\"click\",function(e)&#123; if(e.target.nodeName.toLowerCase() ===\"li\")&#123; alert($(e.target).attr(\"data\")); &#125;&#125;) 这样一来，我们就可以只添加一个事件监听器去捕获所有li上触发的事件，并做出相应的操作。 当然，我们不必每次都做事件源的判断工作，可以将其抽象一下交给工具类来完成。jquery中的delegate()方法就实现了该功能 语法是这样的$(selector).delegate(childSelector,event,data,function)，例如： 123$(\"div\").delegate(\"button\",\"click\",function()&#123; $(\"p\").slideToggle();&#125;); 参数描述childSelector必需。规定要附加事件处理程序的一个或多个子元素。event必需。规定附加到元素的一个或多个事件。由空格分隔多个事件值。必须是有效的事件。data可选。规定传递到函数的额外数据。function必需。规定当事件发生时运行的函数。 Tips：事件委托还有一个好处就是，即使在事件绑定之后动态添加的元素上触发的事件同样可以监听到哦，这样就不用在每次动态加入元素到页面后都为其绑定事件了 转自：http://www.cnblogs.com/gewei/archive/2013/03/29/2988180.html","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"优化","slug":"优化","permalink":"http://007sair.github.io/tags/优化/"}]},{"title":"escape、encodeURI和encodeURIComponent的区别","slug":"js-encode","date":"2015-09-27T16:00:00.000Z","updated":"2018-07-26T07:08:26.512Z","comments":true,"path":"2015/09/28/js-encode/","link":"","permalink":"http://007sair.github.io/2015/09/28/js-encode/","excerpt":"最近在项目中用到对一段url进行编码，因此整理如下： javascript中对文字的编码有3组函数： escape / unescape encodeURI / decodeURI encodeURIComponent / decodeURIComponent","text":"最近在项目中用到对一段url进行编码，因此整理如下： javascript中对文字的编码有3组函数： escape / unescape encodeURI / decodeURI encodeURIComponent / decodeURIComponent escape()该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： * @ - _ + . / 。其他所有的字符都会被转义序列替换。 12console.log(escape(\"Visit W3School!\") + \"&lt;br /&gt;\"); //Visit%20W3School%21console.log(escape(\"?!=()#%&amp;\")); //%3F%21%3D%28%29%23%25%26 结论：js使用数据时可以使用escape encodeURI()该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &#39; ( ) 。 该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,# 123console.log(encodeURI(\"http://www.w3school.com.cn\")+ \"&lt;br /&gt;\"); //http://www.w3school.com.cnconsole.log(encodeURI(\"http://www.w3school.com.cn/My first/\")); //http://www.w3school.com.cn/My%20first/console.log(encodeURI(\",/?:@&amp;=+$#\")); //,/?:@&amp;=+$# 结论：进行url跳转时可以整体使用encodeURI encodeURIComponent()该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &#39; ( ) 。其他字符（比如：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 123console.log(encodeURIComponent(\"http://www.w3school.com.cn\")); //http%3A%2F%2Fwww.w3school.com.cnconsole.log(encodeURIComponent(\"http://www.w3school.com.cn/p 1/\")); //http%3A%2F%2Fwww.w3school.com.cn%2Fp%201%2Fconsole.log(encodeURIComponent(\",/?:@&amp;=+$#\")); //%2C%2F%3F%3A%40%26%3D%2B%24%23 结论：传递参数时需要使用encodeURIComponent，这样组合的url才不会被#等特殊字符截断。 综合结论 escape()除了ASCII字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。 encodeURI()用于编码整个URI,因为URI中的合法字符都不会被编码转换。 encodeURIComponent()方法在编码单个URIComponent（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"前端资源整理","slug":"web-note","date":"2015-09-24T16:00:00.000Z","updated":"2018-07-26T07:08:26.512Z","comments":true,"path":"2015/09/25/web-note/","link":"","permalink":"http://007sair.github.io/2015/09/25/web-note/","excerpt":"","text":".lotus-post h2{} .lotus-post h3{ font-size: 1.3em;} .lotus-post h4{ margin-left: 2em; font-size: 1.1em;} .lotus-post ul{ margin-left: 5.5em; margin-bottom: 5px;} .lotus-post li{ font-size: 0.9em;} .lotus-post p{ margin-bottom: 0.2em;} $(document).ready(function() { //为超链接加上target='_blank'属性 $('a[href^=\"http\"]').each(function() { $(this).attr({ 'target' : '_blank', 'rel' : 'nofollow' }); }); }); 专业类HTML HTML5标签使用的常见误区 22个HTML5的初级技巧 HTML5的革新——语义化标签(一) HTML5的革新：结构之美 CSS css解决方案_W3cplus css选择器的浏览器支持 css选择器详解 css中单位px和em,rem的区别 css3属性详解 css Reset 详细分析 css3 content 生成内容 css3-flexbox/zh-hans Javascript javaScript入门学习书籍的阶段选择 javascript核心 优化 HOW TO LOSE WEIGHT in the browser 移动H5前端性能优化指南 cssReset normalize.css 规范 Web前端开发规范文档 百度，淘宝，腾讯三大巨头HTML页面规范分解 编码规范 by @mdo 编码规范 from github 学习类 Frontend Knowledge Structure 免费的编程中文书籍索引 正则表达式30分钟入门教程 课程库 - 极客标签 妙味课堂 - 需购买才能看 一步步学会使用SeaJS 2.0 工具类Emmet 英文文档 中文文档 Git Git教程（本文由 @廖雪峰 创作，如果觉得本教程对您有帮助，可以去 iTunes 购买） git简明指南 猴子都能懂的GIT入门 Git 参考手册 Pro Git 中文版 Git-Cheat-Sheet 框架 AngularJS中文网 React概览 Bootstrap中文网 Amaze UI Foundation中文网 Nice Easy Javascript NEC：更好的css样式解决方案 压缩工具 http://tool.css-js.com/ 在线工具集合 前端开发仓库 前端开发工具大全-武方博收集整理 前端开发神器-w3cfuns 资源类网站 蓝色理想wiki 前端技术专栏 - w3cfuns 妙味 领先的HTML5动效搜索和分享引擎 - 踏得网 资源 Browserhacks - 一个针对hack的网站！！ CSS3字体模块 字体下载-求字体网 自动化构建Gulp Gulp 中文网 前端构建工具gulp入门教程 plugin registry npm Gulp —— 另一种自动化流水线 Sass sass入门 sass中国 sass参考手册 sass Functions 杂谈 程序员装B指南手册","categories":[{"name":"web","slug":"web","permalink":"http://007sair.github.io/categories/web/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"web","slug":"web","permalink":"http://007sair.github.io/tags/web/"}]},{"title":"JS 面向对象的程序设计","slug":"js-oop","date":"2015-09-20T16:00:00.000Z","updated":"2018-07-26T07:08:26.511Z","comments":true,"path":"2015/09/21/js-oop/","link":"","permalink":"http://007sair.github.io/2015/09/21/js-oop/","excerpt":"面向对象的语言有一个标志，那就是都有类的概念。通过类可以创建任意多个具有相同属性和方法的对象。ECMAScript中没有类的概念，因此它的对象与纯面向对象语言中的对象是不同的。","text":"面向对象的语言有一个标志，那就是都有类的概念。通过类可以创建任意多个具有相同属性和方法的对象。ECMAScript中没有类的概念，因此它的对象与纯面向对象语言中的对象是不同的。 ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数”。可以简单理解为JS的对象是一组无序的值，其中的属性或方法都有一个名字，根据这个名字可以访问相映射的值（值可以是基本值/对象/方法）。 一、理解对象基于Object对象创建自定义对象最简单的方法就是创建一个Object的实例，然后再为它添加属性和方法： 12345678var person = new Object();person.name = 'Nicholas';person.age = 29;person.job = 'Software Engineer';person.sayName = function()&#123; console.log(this.name);&#125;; 字面量方式12345678var person = &#123; name : 'Nicholas', age : 29, job : 'Software Engineer', sayName : function()&#123; console.log(this.name); &#125;&#125;; JS的对象可以使用.操作符动态的扩展其属性，可以使用delete操作符或将属性值设置为undefined来删除属性。如下： 1234person.newAtt='new Attr'; //添加属性console.log(person.newAtt); //new Attrdelete person.age;console.log(person.age); //undefined(删除属性后值为undefined); 二、创建对象虽然Object构造函数或对象字面量都可以创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复代码。为解决这个问题，人们开始使用工厂模式的一种变体： 工厂模式工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。因为ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定的接口创建对象的细节，如下： 123456789101112function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; return this.name; &#125; return o; //使用return返回生成的对象&#125;var person1 = createPerson('Nicholas', 29, 'SoftWare Engineer');var person2 = createPerson('Greg', 27, 'Doctor'); 创建对象交给一个工厂方法来实现，可以传递参数，但主要缺点是无法识别对象类型，因为创建对象都是使用Object的原生构造函数来完成的。 构造函数模式ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法，如下： 1234567891011function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; console.log(this.name); &#125;&#125;var person1 = new Person('Nicholas', 29, 'SoftWare Engineer');var person2 = new Person('Greg', 27, 'Doctor'); 使用自定义的构造函数（与普通函数一样，只是用它来创建对象），定义对象类型（如：Person）的属性和方法。它与工厂方法区别在于： 没有显式地创建对象； 直接将属性和方法赋值给了this对象； 没有return语句。 此外，要创建Person的实例，必须使用new关键字，以Person函数为构造函数，传递参数完成对象创建；实际创建经过以下4个过程： 创建一个对象； 将函数的作用域赋给新对象（因此this指向这个新对象，如：person1）； 执行构造函数的代码； 返回该对象。 在前面例子的最后，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个constructor（构造函数）属性，该属性指向创建这个实例的函数对象，即Person，如下： 12console.log(person1.constructor === Person); //trueconsole.log(person2.constructor === Person); //true 对象的constructor属性最初是用来标书对象类型的。针对对象类型的检测，还是instanceof操作符更可靠： 12345console.log(person1 instanceof Person); //true;console.log(person1 instanceof Object); //true;console.log(person2 instanceof Person); //true;console.log(person2 instanceof Object); //true; 创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型——这正是构造函数模式胜过工厂模式的地方。 1.将构造函数当做函数构造函数与其他函数的唯一区别，就在于调用它们的方式不同。构造函数本身也是函数，不存在特殊定义特殊语法。任何函数，只要通过new操作符调用，那它就可以作为构造函数，反之，不通过new，那就跟普通函数没什么两样。如下： 123456789101112//当作构造函数使用var person = new Person('Nicholas', 29, 'SoftWare Engineer');person.sayName(); //\"Nicholas\"//当作普通函数调用，并且作用域在window上Person('Greg',27,'Doctor');window.sayName(); //\"Greg\"//在另一个对象的作用域中调用var o = &#123;&#125;;Person.call(o, 'chan', 25, '切图仔');o.sayName(); //\"chan\" 2.构造函数的问题构造函数模式虽然好用，但并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。前面例子中，person1和person2都有一个名为sayName()的方法，但两个方法不是同一个Function的实例。不要忘了———ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。所以上面代码可以主要定义： 123456function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = new Function('console.log(this.name)'); //与声明函数在逻辑上是等价的&#125; 上述代码，创建多个实例时，会重复调用new Function();创建多个函数实例，这些函数实例还不是一个作用域中，当然这一般不会有错，但这会造成内存浪费。当然，可以在函数中定义一个sayName = sayName的引用，而sayName函数在Person外定义，这样可以解决重复创建函数实例问题，但在效果上并没有起到封装的效果，如下所示： 123456789function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = sayName; //指向外部全局函数的指针&#125;function sayName() &#123; console.log(this.name);&#125; 原型模式JS中每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按照字面意思理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象，即：它是所有通过new操作符使用函数创建的实例的原型对象。原型对象最大特点是，所有对象实例共享它所包含的属性和方法，换句话说，不必在构造函数中定义对象实例的信息，可以将这些信息直接添加到原型对象中，如下： 123456789101112function Person()&#123; // 空的构造函数&#125;Person.prototype.name = 'Nicholas';//使用原型来添加属性Person.prototype.age = 29;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();console.log(person1.sayName()); //\"Nicholas\"var person2 = new Person();console.log(person1.sayName === person2.sayName); //true;共享一个原型对象的方法 1.理解原型对象无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。拿前面的例子来说，Person函数有一个prototype属性，Person.prototype有一个constructor属性，这个属性指向指向Person。如下： 123Person.prototype //Person &#123;name: \"Nicholas\", age: 29&#125;Person.prototype.constructor //Person()Person.prototype.constructor == Person //true 创建自定义构造函数后，其原型对象默认只会取得constructor属性，其他属性都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但FF、Safari、Chrome都暴露了一个__proto__；不过，要明确真正重要的一点是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 实例属性或方法的访问过程是一次搜索过程： 首先从对象实例本身开始，如果找到属性就直接返回该属性值； 如果实例本身不存在要查找的属性，就继续搜索指针指向的原型对象，在其中查找给定名字的属性，如果有就返回。 基于以上分析，原型模式创建的对象实例，其属性是共享原型对象的；但也可以自己实例中再进行定义，在查找时，就不从原型对象获取，而是根据搜索原则，得到本实例的返回；简单来说，就是实例中属性会屏蔽原型对象中的属性； 2.原型与in操作符一句话：无论原型中属性，还是对象实例的属性，都可以使用in操作符访问到；要想判断是否是实例本身的属性可以使用object.hasOwnProperty(&#39;attr&#39;)来判断； 1234567891011121314151617181920212223242526272829function Person()&#123; //空的&#125;Person.prototype.name = 'chan';Person.prototype.age = 29;Person.prototype.job = '切图仔';Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();var person2 = new Person();console.log(person1.hasOwnProperty('name')); //falseconsole.log('name' in person1); //trueperson1.name = 'long';console.log(person1.name); //\"long\" ————来自实例console.log(person1.hasOwnProperty('name')); //trueconsole.log('name' in person1); //trueconsole.log(person2.name); //\"chan\" ————来自原型console.log(person2.hasOwnProperty('name')); //falseconsole.log('name' in person2); //truedelete person1.name;console.log(person1.name); //\"chan\" ————实例属性已被删除，来自原型console.log(person1.hasOwnProperty('name')); //falseconsole.log('name' in person1); //true 3.原生对象中原型原型模式的重要性不仅体现在创建自定义类型，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String、等等）都是其构造函数的原型上定义了方法。 原生对象中原型与普通对象的原型一样，可以添加/修改属性或方法，如以下代码为所有字符串对象添加去左右空白原型方法： 12345String.prototype.trim = function()&#123; return this.replace(/^\\s+/,'').replace(/\\s+$/,'');&#125;;var str = ' word space ';console.log('!'+str.trim()+'!'); //!word space! 4.原型对象的问题原型模式的缺点，它省略了为构造函数传递初始化参数，这在一定程序带来不便；另外，最主要是当对象的属性是引用类型时，它的值是不变的，总是引用同一个外部对象，所有实例对该对象的操作都会其它实例： 123456789function Person() &#123; //空函数&#125;Person.prototype.name = 'Jack';Person.prototype.lessons = ['Math','Physics'];var person1 = new Person();person1.lessons.push('Biology');var person2 = new Person();console.log(person2.lessons); //Math,Physics,Biology，person1修改影响了person2 组合构造函数及原型模式目前最为常用的定义类型方式，是组合构造函数模式与原型模式。构造函数模式用于定义实例的属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方方法的引用，最大限度的节约内存。此外，组合模式还支持向构造函数传递参数，可谓是集两家之所长。 1234567891011121314151617181920212223function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ['Shelby', 'Court'];&#125;Person.prototype = &#123; constructor: Person, //原型字面量方式会将对象的constructor变为Object，此外强制指回Person sayName: function()&#123; console.log(this.name); &#125;&#125;;var person1 = new Person('Jack', 19, 'SoftWare Engneer');var person2 = new Person('Lily', 39, 'Mechanical Engneer');person1.friends.push('Van');console.log(person1.friends); //[\"Shelby\", \"Court\", \"Van\"]console.log(person2.friends); //[\"Shelby\", \"Court\"]console.log(person1.friends === person2.friends); //falseconsole.log(person1.sayName === person2.sayName); //true 共享原型中定义方法 在所接触的JS库中，jQuery类型的封装就是使用组合模式来实例的！！！ 动态原型模式组合模式中实例属性与共享方法（由原型定义）是分离的，这与纯面向对象语言不太一致；动态原型模式将所有构造信息都封装在构造函数中，又保持了组合的优点。其原理就是通过判断构造函数的原型中是否已经定义了共享的方法或属性，如果没有则定义，否则不再执行定义过程。该方式只原型上方法或属性只定义一次，且将所有构造过程都封装在构造函数中，对原型所做的修改能立即体现所有实例中： 123456789101112131415161718192021function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.lessons = ['Math', 'Physics'];&#125;if (typeof this.sayName != 'function') &#123; //通过判断实例封装 Person.prototype = &#123; constructor: Person, //原型字面量方式会将对象的constructor变为Object，此外强制指回Person sayName: function() &#123; return this.name; &#125; &#125;&#125;var person1 = new Person('Jack', 19, 'SoftWare Engneer');person1.lessons.push('Biology');var person2 = new Person('Lily', 39, 'Mechanical Engneer');console.log(person1.lessons); //Math,Physics,Biologyconsole.log(person2.lessons); //Math,Physicsconsole.log(person1.sayName === person2.sayName); //true,//共享原型中定义方法 以上内容参考自《Javascript高级程序设计》第3版","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"font-size","slug":"font-size","date":"2015-09-14T16:00:00.000Z","updated":"2018-07-26T07:08:26.511Z","comments":true,"path":"2015/09/15/font-size/","link":"","permalink":"http://007sair.github.io/2015/09/15/font-size/","excerpt":"","text":"汉字，¥10.123456789,font-family:默认汉字，¥10.123456789,font-family:”Helvetica Neue”汉字，¥10.123456789,font-family:Helvetica汉字，¥10.123456789,font-family:STHeiTi汉字，¥10.123456789,font-family:Arial汉字，¥10.123456789,font-family:’微软雅黑’","categories":[{"name":"test","slug":"test","permalink":"http://007sair.github.io/categories/test/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"test","slug":"test","permalink":"http://007sair.github.io/tags/test/"}]},{"title":"flex test","slug":"flex-test","date":"2015-09-04T16:00:00.000Z","updated":"2018-07-26T07:08:26.511Z","comments":true,"path":"2015/09/05/flex-test/","link":"","permalink":"http://007sair.github.io/2015/09/05/flex-test/","excerpt":"","text":"测试flex-flow在移动端的兼容问题，用手机打开此页面查看效果。尤其最后一个demo： ul,li{ list-style: none;} .box{ display:-webkit-flex; display:flex; width:220px;margin:0;padding:10px;list-style:none;background-color:#eee;} .box li{width:100px;height:100px;border:1px solid #f00;text-align:center;} #box{ -webkit-flex-wrap:nowrap; flex-wrap:nowrap; } #box2{ -webkit-flex-wrap:wrap; flex-wrap:wrap; } #box3{ -webkit-flex-wrap:wrap-reverse; flex-wrap:wrap-reverse; } #box4{ -webkit-flex-wrap:wrap; flex-wrap:wrap; } #box4 li{ min-width: 40%; width: auto; -webkit-box-flex: 1; -moz-box-flex: 1; -webkit-flex: 1; -ms-flex: 1; flex: 1; } flex-wrap:nowrap a b cflex-wrap:wrap a b cflex-wrap:wrap-reverse a b cflex-wrap:wrap &amp; flex a b c","categories":[{"name":"test","slug":"test","permalink":"http://007sair.github.io/categories/test/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"test","slug":"test","permalink":"http://007sair.github.io/tags/test/"},{"name":"flex","slug":"flex","permalink":"http://007sair.github.io/tags/flex/"}]},{"title":"Array方法: indexOf、filter、forEach、map、reduce详解","slug":"js-Extras","date":"2015-08-16T16:00:00.000Z","updated":"2018-07-26T07:08:26.510Z","comments":true,"path":"2015/08/17/js-Extras/","link":"","permalink":"http://007sair.github.io/2015/08/17/js-Extras/","excerpt":"","text":"ECMAScript5标准新增了几个数组操作的方法，让我们来看看都是什么： Array.prototype.indexOf Array.prototype.lastIndexOf Array.prototype.every Array.prototype.some Array.prototype.forEach Array.prototype.map Array.prototype.filter Array.prototype.reduce Array.prototype.reduceRight 只介绍其中5个方法：indexOf、filter、map、forEach、reduce，其余请参考：http://kangax.github.io/compat-table/es5/ indexOfindexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1。 没有实现这个方法时，我们这么玩： 12345678910function getIndexOf(arr, src)&#123; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == src)&#123; return i; &#125; &#125;; return -1;&#125;var arr = ['a','b','c','d'];console.log(getIndexOf(arr, 'b')); 现在可以这么玩： 12var arr = ['a','b','c','d'];console.log(arr.indexOf('b')); 一般在写老版本的兼容时，我们会这么玩： 12345678910111213Array.prototype.indexOf = function(n)&#123; for (var i = 0; i &lt; this.length; i++) &#123; if(this[i] == n)&#123; return i; &#125; &#125;; return -1;&#125;var arr = ['a','b','c','d'];for(var x in arr)&#123; document.write(arr[x] + '&lt;br&gt;');&#125; 上面代码本身没有问题，但在IE8以下（含IE8）的浏览器上结果是这样的： 12345//a//b//c//d//function(n)&#123; for (var i = 0; i &lt; this.length; i++) &#123; if(this[i] == n)&#123; return i + '-indexOf'; &#125; &#125;; return -1; &#125; 为什么会这样？得先知道一个原理：预定义的属性不是可枚举的，而用户定义的属性总是可枚举的。 在IE8以上的浏览器中，indexOf会被认为是预定义属性，使用for in时自然不会被枚举到。而ie8以下的js版本中并没有预定义indexOf，是我们自定义的方法，所以就被枚举到了。 关于for in：可用来遍历一个对象中的所有属性名，该枚举过程将会列出所有的属性，包括函数和你可能不关心的原型中的属性。 所以上面的例子想得到正确的结果，需做如下修改： 123456789101112131415Array.prototype.indexOf = function(n)&#123; for (var i = 0; i &lt; this.length; i++) &#123; if(this[i] == n)&#123; return i; &#125; &#125;; return -1;&#125;var arr = ['a','b','c','d'];for(var x in arr)&#123; if (arr.hasOwnProperty(x)) &#123; document.write(arr[x] + '&lt;br&gt;'); &#125;&#125; hasOwnProperty：是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。 isPrototypeOf：是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回true，否则返回false。 1234567891011121314151617181920212223242526//一个demo解释hasOwnProperty和isPrototypeOffunction Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.sayHello = function()&#123; console.log('hello, my name is ' + this.age);&#125;Person.prototype.sayFrom = function(from)&#123; this.from = from; console.log('hi, i come from ' + this.from);&#125;var s1 = new Person('xiaomin', '24');var s2 = new Person('xiaohua', '28');s1.grade = '30';console.log(s1.hasOwnProperty('name')); //trueconsole.log(s1.hasOwnProperty('grade')); //trueconsole.log(s1.hasOwnProperty('sayHello')); //falseconsole.log(s1.hasOwnProperty('from')); //falseconsole.log(Person.prototype.hasOwnProperty(\"sayHello\"));//trueconsole.log(Person.prototype.hasOwnProperty(\"from\"));//falseconsole.log(Person.prototype.isPrototypeOf(s1))//trueconsole.log(Person.prototype.isPrototypeOf(s2))//true 关于枚举，可参考： js对象中什么是可枚举性(enumerable)？ JavaScript propertyIsEnumerable() 函数详解 ECMAScript5 Object的新属性方法 JS 对象属性”可枚举” filter该filter()方法创建一个新的匹配过滤条件的数组。 没有实现这个方法时，我们这么玩： 12345678910111213141516var arr = [ &#123;\"name\":\"apple\", \"count\": 2&#125;, &#123;\"name\":\"orange\", \"count\": 5&#125;, &#123;\"name\":\"pear\", \"count\": 3&#125;, &#123;\"name\":\"orange\", \"count\": 16&#125;,]; var newArr = [];for(var i= 0, l = arr.length; i&lt; l; i++)&#123; if(arr[i].name === \"orange\" )&#123; newArr.push(arr[i]); &#125;&#125;console.log(\"Filter results:\",newArr); 现在可以这么玩： 12345678910111213var arr = [ &#123;\"name\":\"apple\", \"count\": 2&#125;, &#123;\"name\":\"orange\", \"count\": 5&#125;, &#123;\"name\":\"pear\", \"count\": 3&#125;, &#123;\"name\":\"orange\", \"count\": 16&#125;,]; var newArr = arr.filter(function(item)&#123; return item.name === \"orange\";&#125;);console.log(\"Filter results:\",newArr); forEachforEach()为每个元素执行对应的方法 12345678910111213var arr = [1,2,3,4,5,6,7,8];// Uses the usual \"for\" loop to iteratefor(var i= 0, l = arr.length; i&lt; l; i++)&#123; console.log(arr[i]);&#125;console.log(\"========================\");//Uses forEach to iteratearr.forEach(function(item,index)&#123; console.log(item);&#125;); map该map()对数组的每个元素进行一定操作（映射）后，会返回一个新的数组， 以前这么玩： 12345678910111213var oldArr = [&#123;first_name:\"Colin\",last_name:\"Toh\"&#125;,&#123;first_name:\"Addy\",last_name:\"Osmani\"&#125;,&#123;first_name:\"Yehuda\",last_name:\"Katz\"&#125;];function getNewArr()&#123; var newArr = []; for(var i= 0, l = oldArr.length; i&lt; l; i++)&#123; var item = oldArr[i]; item.full_name = [item.first_name,item.last_name].join(\" \"); newArr[i] = item; &#125; return newArr;&#125;console.log(getNewArr()); 现在这么玩： 12345678910var oldArr = [&#123;first_name:\"Colin\",last_name:\"Toh\"&#125;,&#123;first_name:\"Addy\",last_name:\"Osmani\"&#125;,&#123;first_name:\"Yehuda\",last_name:\"Katz\"&#125;];function getNewArr()&#123; return oldArr.map(function(item,index)&#123; item.full_name = [item.first_name,item.last_name].join(\" \"); return item; &#125;);&#125;console.log(getNewArr()); map()是处理服务器返回数据时是一个非常实用的函数。 reducereduce()可以实现一个累加器的功能，将数组的每个值（从左到右）将其降低到一个值。 场景： 统计一个数组中有多少个不重复的单词 befroe: 123456789101112var arr = [\"apple\",\"orange\",\"apple\",\"orange\",\"pear\",\"orange\"];function getWordCnt()&#123; var obj = &#123;&#125;; for(var i= 0, l = arr.length; i&lt; l; i++)&#123; var item = arr[i]; obj[item] = (obj[item] +1 ) || 1; &#125; return obj;&#125;console.log(getWordCnt()); now: 12345678910var arr = [\"apple\",\"orange\",\"apple\",\"orange\",\"pear\",\"orange\"];function getWordCnt()&#123; return arr.reduce(function(prev,next)&#123; prev[next] = (prev[next] + 1) || 1; return prev; &#125;,&#123;&#125;);&#125;console.log(getWordCnt()); reduce(callback, initialValue)会传入两个变量。回调函数callback和初始值initialValue。假设函数它有个传入参数，prev和next,index和array。prev和next你是必须要了解的。 一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值initialValue后，第一个prev将是initivalValue，next将是数组中的第一个元素。 12345678910111213141516171819202122232425//二者的区别，在console中运行一下即可知晓var arr = [\"apple\",\"orange\"];function noPassValue()&#123; return arr.reduce(function(prev,next)&#123; console.log(\"prev:\",prev); console.log(\"next:\",next); return prev + \" \" +next; &#125;);&#125;function passValue()&#123; return arr.reduce(function(prev,next)&#123; console.log(\"prev:\",prev); console.log(\"next:\",next); prev[next] = 1; return prev; &#125;,&#123;&#125;);&#125;console.log(\"No Additional parameter:\",noPassValue());console.log(\"----------------\");console.log(\"With &#123;&#125; as an additional parameter:\",passValue());","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"array","slug":"array","permalink":"http://007sair.github.io/tags/array/"}]},{"title":"Javascript中如何遍历属性","slug":"js-for-in","date":"2015-08-16T16:00:00.000Z","updated":"2018-07-26T07:08:26.511Z","comments":true,"path":"2015/08/17/js-for-in/","link":"","permalink":"http://007sair.github.io/2015/08/17/js-for-in/","excerpt":"","text":"遍历属性，我们首先要搞清楚for in，再来谈遍历： 关于for infor...in 声明用于对数组或者对象的属性进行循环/迭代操作。1234567891011121314151617// 对于数组：迭代出来的是数组元素var mycars = ['Saab','Volvo','BMW']; for (x in mycars) &#123; console.log(x); // 0 1 2 console.log(mycars[x]); // Saab Volvo BMW&#125; // 对于对象 ，迭代出来的是对象的属性var obj = &#123; w: \"wen\", j: \"jian\", b: \"bao\" &#125; for(var v in obj)&#123; console.log(v); // w j b console.log(obj[v]); // wen jian bao&#125; 判断对象是否为 数组/对象 的 元素/属性：语法为： 123for (变量 in 对象) &#123; 在此执行代码&#125; 当“对象”为数组时，变量指的是数组的下标（索引）； 1234567var arr = [\"a\",\"b\",\"2\",\"3\",\"str\"]; var result = (\"b\" in arr); var result1 = (4 in arr); console.log(result); //falseconsole.log(result1); //true 当“对象”为对象时，变量指的是对象的属性； 1234567891011var obj = &#123; w:\"wen\", j:\"jian\", b:\"bao\" &#125;; var result = (2 in obj); var result1 = (\"j\" in obj); console.log(result); //falseconsole.log(result1); //true 关于for in的其他参考： for in的缺陷 各浏览器中for in顺序的差异 关于遍历在JavaScript中，遍历一个对象的属性往往没有在其他语言中遍历一个哈希(有些语言称为字典)的键那么简单，这主要有两个方面的原因： JavaScript中的对象通常都处在某个原型链中,它会从一个或多个的上层原型上继承一些属性； JavaScript中的属性不光有值,它还有一些除了值以外的其他特性,其中一个影响属性遍历的特性就是[[Enumerable]],如果该值为true,则称这个属性是可枚举的,否则反之。 知道了这些,我们就可以把属性的遍历分为四种情况： 注：示例代码中,我们要遍历的对象是浏览器中的window,环境为Chrome43.0.2357.134,代码运行在空白页面中的script标签里.没有Firebug或者其他调试工具的影响(会导入一些全局变量,console等)。 遍历可枚举的自身属性可枚举的意思就是该属性的[[Enumerable]]（可枚举性）特性为true，自身属性的意思就是该属性不是从原型链上继承下来的。 123456(function () &#123; var propertys = Object.keys(window); //获得对象上所有可枚举的“实例属性” console.log(propertys.length); //chrome为7 [\"top\", \"location\", \"document\", \"window\", \"external\", \"chrome\", \"propertys\"] console.log(window); console.log(propertys); //window,document,InstallTrigger,除了最后一个是火狐私有的属性,原来window对象只有两个可枚举的自身属性.window属性指向window对象自身,一般没什么用.&#125;)(); 遍历所有的自身属性特性为不可枚举的属性也并不是遍历不到,ES5给我们提供了getOwnPropertyNames方法,可以获取到一个对象的所有自身属性. 12345(function () &#123; var propertys = Object.getOwnPropertyNames(window); //获得对象上所有的“实例属性” console.log(propertys.length); //chrome为571 console.log(propertys.join(\"\\n\")); //Object,Function,eval等等&#125;)(); 遍历可枚举的自身属性和继承属性继承属性怎么遍历,你应该知道,就是最常用的for in遍历 123456789101112(function () &#123; var getEnumPropertyNames = function (obj) &#123; var props = []; for (prop in obj) &#123; props.push(prop); &#125; return props; &#125; var propertys = getEnumPropertyNames(window); console.log(propertys.length); // chrome为186 console.log(propertys.join(\"\\n\")); // addEventListener,onload等等&#125;)(); 遍历所有的自身属性和继承属性这种遍历主要用在各种js调试工具的代码补全功能上.比如Firebug的. 123456789101112(function () &#123; var getAllPropertyNames = function (obj) &#123; var props = []; do &#123; props = props.concat(Object.getOwnPropertyNames(obj)); &#125; while (obj = Object.getPrototypeOf(obj)); return props; &#125; var propertys = getAllPropertyNames(window); console.log(propertys.length); // chrome为719 console.log(propertys.join(\"\\n\")); // toString等&#125;)();","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"图解Javascript原型链","slug":"js-tujie-proto","date":"2015-08-14T16:00:00.000Z","updated":"2018-07-26T07:08:26.510Z","comments":true,"path":"2015/08/15/js-tujie-proto/","link":"","permalink":"http://007sair.github.io/2015/08/15/js-tujie-proto/","excerpt":"昨天翻微信订阅号，无意间看到这篇关于原型和原型链的文章，觉得其中有很多值得学习的地方，整理如下： 本文尝试阐述Js中原型（prototype）、原型链（prototype chain）等概念及其作用机制。上一篇文章（图解Javascript上下文与作用域）介绍了Js中变量作用域的相关概念，实际上关注的一个核心问题是：“在执行当前这行代码时Js解释器可以获取哪些变量”，而原型与原型链实际上还是关于这一问题。 我们知道，在Js中一切皆为对象（Object），但是Js中并没有类（class）；Js是基于原型（prototype-based）来实现的面向对象（OOP）的编程范式的，但并不是所有的对象都拥有prototype这一属性：","text":"昨天翻微信订阅号，无意间看到这篇关于原型和原型链的文章，觉得其中有很多值得学习的地方，整理如下： 本文尝试阐述Js中原型（prototype）、原型链（prototype chain）等概念及其作用机制。上一篇文章（图解Javascript上下文与作用域）介绍了Js中变量作用域的相关概念，实际上关注的一个核心问题是：“在执行当前这行代码时Js解释器可以获取哪些变量”，而原型与原型链实际上还是关于这一问题。 我们知道，在Js中一切皆为对象（Object），但是Js中并没有类（class）；Js是基于原型（prototype-based）来实现的面向对象（OOP）的编程范式的，但并不是所有的对象都拥有prototype这一属性： 12345678var a = &#123;&#125;; console.log(a.prototype); //=&gt; undefinedvar b = function()&#123;&#125;; console.log(b.prototype); //=&gt; &#123;&#125;var c = 'Hello'; console.log(c.prototype); //=&gt; undefined prototype是每个function定义时自带的属性，但是Js中function本身也是对象，我们先来看一下下面几个概念的差别： function、Function、Object和{}function是javascript的一个关键词，用于定义函数类型的变量，有两种语法形式： 123456789function f1()&#123; console.log('This is function f1!');&#125;typeof(f1); //=&gt; 'function'var f2 = function()&#123; console.log('This is function f2!');&#125;typeof(f2); //=&gt; 'function' 如果用更加面向对象的方法来定义函数，可以用Function： 12345var f3 = new Function(\"console.log('This is function f3!');\"); f3(); //=&gt; 'This is function f3!' typeof(f3); //=&gt; 'function'typeof(Function); //=&gt; 'function' 实际上Function就是一个用于构造函数类型变量的类，或者说是函数类型实例的构造函数（constructor）；与之相似有的Object或String、Number等，都是Js内置类型实例的构造函数。比较特殊的是Object，它用于生成对象类型，其简写形式为{}： 1234567var o1 = new Object(); typeof(o1); //=&gt; 'object'var o2 = &#123;&#125;; typeof(o2); //=&gt; 'object'typeof(Object); //=&gt; 'function' prototype VS [[proto]]清楚了上面的概念之后再来看prototype： Each function has two properties： length and prototype prototype和length是每一个函数类型自带的两个属性，而其它非函数类型并没有（开头的例子已经说明），这一点之所以比较容易被忽略或误解，是因为所有类型的构造函数本身也是函数，所以它们自带了prototype属性： 1234//Nodeconsole.log(Object.prototype); //=&gt; Object &#123;&#125;console.log(Function.prototype); //=&gt; function Empty()console.log(String.prototype); //=&gt; String &#123;length: 0, [[PrimitiveValue]]: \"\"&#125; 除了prototype之外，Js中的所有对象（undefined、null等特殊情况除外）都有一个内置的__proto__属性，指向它“父类”的prototype，这个内置属性在ECMA标准中并没有给出明确的获取方式，但是许多Js的实现（如Node、大部分浏览器等）都提供了一个__proto__属性来指代这一[[Prototype]]，我们通过下面的例子来说明实例中的__proto__是如何指向构造函数的prototype的： 1234567891011var Person = function()&#123;&#125;; Person.prototype.type = 'Person'; Person.prototype.maxAge = 100;var p = new Person(); console.log(p.maxAge); p.name = 'rainy';Person.prototype.constructor === Person; //=&gt; true p.__proto__ === Person.prototype; //=&gt; true console.log(p.prototype); //=&gt; undefined 上面的代码示例可以用下图解释： Person是一个函数类型的变量，因此自带了prototype属性，prototype属性中的constructor又指向Person本身；通过new关键字生成的Person类的实例p1，通过__proto__属性指向了Person的原型。这里的__proto__只是为了说明实例p1在内部实现的时候与父类之间存在的关联（指向父类的原型），在实际操作过程中实例可以直接通过.获取父类原型中的属性，从而实现了继承的功能。 原型链清楚了prototype与__proto__的概念与关系之后我们会对“Js中一切皆为对象”这句话有更加深刻的理解。进而我们会想到，既然__proto__是（几乎）所有对象都内置的属性，而且指向父类的原型，那是不是意味着我们可以“逆流而上”一直找到源头呢？我们来看下面的例子： 1234567891011121314151617// Nodevar Obj = function()&#123;&#125;; var o = new Obj(); o.__proto__ === Obj.prototype; //=&gt; true o.__proto__.constructor === Obj; //=&gt; trueObj.__proto__ === Function.prototype; //=&gt; true Obj.__proto__.constructor === Function; //=&gt; trueFunction.__proto__ === Function.prototype; //=&gt; true Object.__proto__ === Object.prototype; //=&gt; false Object.__proto__ === Function.prototype; //=&gt; trueFunction.__proto__.constructor === Function;//=&gt; true Function.__proto__.__proto__; //=&gt; &#123;&#125; Function.__proto__.__proto__ === o.__proto__.__proto__; //=&gt; true o.__proto__.__proto__.__proto__ === null; //=&gt; true 从上面的例子和图解可以看出，prototype对象也有__proto__属性，向上追溯一直到null。 new关键词的作用就是完成上图所示实例与父类原型之间关系的串接，并创建一个新的对象；instanceof关键词的作用也可以从上图中看出，实际上就是判断__proto__（以及__proto__.__proto__...）所指向是否父类的原型： 12345678910var Obj = function()&#123;&#125;; var o = new Obj();o instanceof Obj; //=&gt; true o instanceof Object; //=&gt; true o instanceof Function; //=&gt; falseo.__proto__ === Obj.prototype; //=&gt; true o.__proto__.__proto__ === Object.prototype; //=&gt; true o.__proto__.__proto__ === Function; //=&gt; false 转自：图解Javascript原型链 参考自： JavaScript constructors, prototypes, and the new keyword Javascript 面向对象编程 Professional JavaScript for Web Developers","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"原型","slug":"原型","permalink":"http://007sair.github.io/tags/原型/"}]},{"title":"图解Javascript上下文与作用域","slug":"js-tujie-context","date":"2015-08-14T16:00:00.000Z","updated":"2018-07-26T07:08:26.510Z","comments":true,"path":"2015/08/15/js-tujie-context/","link":"","permalink":"http://007sair.github.io/2015/08/15/js-tujie-context/","excerpt":"本文尝试阐述Js中的上下文与作用域背后的机制，主要涉及到执行上下文（execution context）、作用域链（scope chain）、闭包（closure）、this等概念。 Execution context执行上下文（简称上下文）决定了Js执行过程中可以获取哪些变量、函数、数据，一段程序可能被分割成许多不同的上下文，每一个上下文都会绑定一个变量对象（variable object），它就像一个容器，用来存储当前上下文中所有已定义或可获取的变量、函数等。位于最顶端或最外层的上下文称为全局上下文（global context），全局上下文取决于执行环境，如Node中的global和Browser中的window：","text":"本文尝试阐述Js中的上下文与作用域背后的机制，主要涉及到执行上下文（execution context）、作用域链（scope chain）、闭包（closure）、this等概念。 Execution context执行上下文（简称上下文）决定了Js执行过程中可以获取哪些变量、函数、数据，一段程序可能被分割成许多不同的上下文，每一个上下文都会绑定一个变量对象（variable object），它就像一个容器，用来存储当前上下文中所有已定义或可获取的变量、函数等。位于最顶端或最外层的上下文称为全局上下文（global context），全局上下文取决于执行环境，如Node中的global和Browser中的window： 需要注意的是，上下文与作用域（scope）是不同的概念。Js本身是单线程的，每当有function被执行时，就会产生一个新的上下文，这一上下文会被压入Js的上下文堆栈（context stack）中，function执行结束后则被弹出，因此Js解释器总是在栈顶上下文中执行。在生成新的上下文时，首先会绑定该上下文的变量对象，其中包括arguments和该函数中定义的变量；之后会创建属于该上下文的作用域链（scope chain），最后将this赋予这一function所属的Object，这一过程可以通过下图表示： this上文提到this被赋予function所属的Object，具体来说，当function是定义在global对中时，this指向global；当function作为Object的方法时，this指向该Object： 123456789101112131415var x = 1; var f = function()&#123; console.log(this.x);&#125;f(); // -&gt; 1var ff = function()&#123; this.x = 2; console.log(this.x);&#125;ff(); // -&gt; 2 x // -&gt; 2var o = &#123;x: \"o's x\", f: f&#125;; o.f(); // \"o's x\" Scope chain上文提到，在function被执行时生成新的上下文时会先绑定当前上下文的变量对象，再创建作用域链。我们知道function的定义是可以嵌套在其他function所创建的上下文中，也可以并列地定义在同一个上下文中（如global）。作用域链实际上就是自下而上地将所有嵌套定义的上下文所绑定的变量对象串接到一起，使嵌套的function可以“继承”上层上下文的变量，而并列的function之间互不干扰： 1234567891011121314151617181920var x = 'global'; function a()&#123; var x = \"a's x\"; function b()&#123; var y = \"b's y\"; console.log(x); &#125;; b();&#125;function c()&#123; var x = \"c's x\"; function d()&#123; console.log(y); &#125;; d();&#125;a(); // -&gt; \"a's x\" c(); // -&gt; ReferenceError: y is not defined x // -&gt; \"global\" y // -&gt; ReferenceError: y is not defined Closure如果理解了上文中提到的上下文与作用域链的机制，再来看闭包的概念就很清楚了。每个function在调用时会创建新的上下文及作用域链，而作用域链就是将外层（上层）上下文所绑定的变量对象逐一串连起来，使当前function可以获取外层上下文的变量、数据等。如果我们在function中定义新的function，同时将内层function作为值返回，那么内层function所包含的作用域链将会一起返回，即使内层function在其他上下文中执行，其内部的作用域链仍然保持着原有的数据，而当前的上下文可能无法获取原先外层function中的数据，使得function内部的作用域链被保护起来，从而形成“闭包”。看下面的例子： 1234567891011121314151617var x = 100; var inc = function()&#123; var x = 0; return function()&#123; console.log(x++); &#125;;&#125;;var inc1 = inc(); var inc2 = inc();inc1(); // -&gt; 0 inc1(); // -&gt; 1 inc2(); // -&gt; 0 inc1(); // -&gt; 2 inc2(); // -&gt; 1 x; // -&gt; 100 执行过程如下图所示，inc内部返回的匿名function在创建时生成的作用域链包括了inc中的x，即使后来赋值给inc1和inc2之后，直接在global context下调用，它们的作用域链仍然是由定义中所处的上下文环境决定，而且由于x是在function inc中定义的，无法被外层的global context所改变，从而实现了闭包的效果： this in closure我们已经反复提到执行上下文和作用域实际上是通过function创建、分割的，而function中的this与作用域链不同，它是由执行该function时当前所处的Object环境所决定的，这也是this最容易被混淆用错的一点。一般情况下的例子如下： 12345678var name = \"global\"; var o = &#123; name: \"o\", getName: function()&#123; return this.name &#125;&#125;;o.getName(); // -&gt; \"o\" 由于执行o.getName()时getName所绑定的this是调用它的o，所以此时this == o；更容易搞混的是在closure条件下： 12345678910var name = \"global\"; var oo = &#123; name: \"oo\", getNameFunc: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;oo.getNameFunc()(); // -&gt; \"global\" 此时闭包函数被return后调用相当于： 12getName = oo.getNameFunc(); getName(); // -&gt; \"global\" 换一个更明显的例子： 12345var ooo = &#123; name: \"ooo\", getName: oo.getNameFunc() // 此时闭包函数的this被绑定到新的Object&#125;;ooo.getName(); // -&gt; \"ooo\" 当然，有时候为了避免闭包中的this在执行时被替换，可以采取下面的方法： 1234567891011var name = \"global\"; var oooo = &#123; name: \"ox4\", getNameFunc: function()&#123; var self = this; return function()&#123; return self.name; &#125;; &#125;&#125;;oooo.getNameFunc()(); // -&gt; \"ox4\" 或者是在调用时强行定义执行的Object： 1234567891011var name = \"global\"; var oo = &#123; name: \"oo\", getNameFunc: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;oo.getNameFunc()(); // -&gt; \"global\" oo.getNameFunc().bind(oo)(); // -&gt; \"oo\" 总结Js是一门很有趣的语言，由于它的很多特性是针对HTML中DOM的操作，因而显得随意而略失严谨，但随着前端的不断繁荣发展和Node的兴起，Js已经不再是&quot;toy language&quot;或是jQuery时代的”CSS扩展”，本文提到的这些概念无论是对新手还是从传统Web开发中过度过来的Js开发人员来说，都很容易被混淆或误解，希望本文可以有所帮助。 写这篇总结的原因是我在Github上分享的Learn javascript in one picture，刚开始有人质疑这只能算是一张语法表（syntax cheat sheet），根本不会涉及更深层的闭包、作用域等内容，但是出乎意料的是这个项目竟然获得3000多个star，所以不能虎头蛇尾，以上。 转自：图解Javascript上下文与作用域 参考自： Understanding Scope and Context in JavaScript this - JavaScript | MDN 闭包 - JavaScript | MDN","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"js 中 this 关键字详解","slug":"js-this","date":"2015-08-09T16:00:00.000Z","updated":"2018-07-26T07:08:26.510Z","comments":true,"path":"2015/08/10/js-this/","link":"","permalink":"http://007sair.github.io/2015/08/10/js-this/","excerpt":"本文主要解释在JS里面this关键字的指向问题(在浏览器环境下)。 首先，必须搞清楚在JS里面，函数的几种调用方式: 普通函数调用 作为方法来调用 作为构造函数来调用 使用apply/call方法来调用 Function.prototype.bind方法","text":"本文主要解释在JS里面this关键字的指向问题(在浏览器环境下)。 首先，必须搞清楚在JS里面，函数的几种调用方式: 普通函数调用 作为方法来调用 作为构造函数来调用 使用apply/call方法来调用 Function.prototype.bind方法 但是不管函数是按哪种方法来调用的，请记住一点：谁调用这个函数或方法，this关键字就指向谁。 接下来就分情况来讨论下这些不同的情况： 普通函数调用123456function person()&#123; this.name = \"xl\"; console.log(this); console.log(this.name);&#125;person(); //输出 window xl 在这段代码中person函数作为普通函数调用，实际上person是作为全局对象window的一个方法来进行调用的，即window.person(); 所以这个地方是window对象调用了person方法，那么person函数当中的this即指window，同时window还拥有了另外一个属性name，值为xl. 12345var name = \"xl\";function person()&#123; console.log(this.name);&#125;person(); //输出 xl 同样这个地方person作为window的方法来调用，在代码的一开始定义了一个全局变量name，值为xl，它相当于window的一个属性，即window.name=&quot;xl&quot;，又因为在调用person的时候this是指向window的，因此这里会输出xl. 作为对象的方法来调用在上面的代码中，普通函数的调用即是作为window对象的方法进行调用。显然this关键字指向了window对象. 再来看下其他的形式 12345678910111213var name = \"XL\";var person = &#123; name: \"xl\", showName: function()&#123; console.log(this.name); &#125;&#125;person.showName(); //输出 xl//这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出namevar showNameA = person.showName;showNameA(); //输出 XL//这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA()，即window对象调用showNameA这个方法，所以this关键字指向window 再换种形式： 12345678910111213var personA = &#123; name: \"xl\", showName: function()&#123; console.log(this.name); &#125;&#125;var personB = &#123; name: \"XL\", sayName: personA.showName&#125;personB.sayName(); //输出 XL//虽然showName方法是在personA这个对象中定义，但是调用的时候却是在personB这个对象中调用，因此this对象指向 作为构造函数来调用1234567891011function Person(name)&#123; this.name = name;&#125;var personA = Person(\"xl\");console.log(personA.name); // 输出 undefinedconsole.log(window.name);//输出 xl//上面代码没有进行new操作，相当于window对象调用Person(\"xl\")方法，那么this指向window对象，并进行赋值操作window.name=\"xl\".var personB = new Person(\"xl\");console.log(personB.name);// 输出 xl//这部分代码的解释见下 new操作符12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程function person(name)&#123; var o = &#123;&#125;; o.__proto__ = Person.prototype; //原型继承 Person.call(o, name); return o;&#125;var personB = person(\"xl\");console.log(personB.name); // 输出 xl 步骤如下： 在person里面首先创建一个空对象o； 将o的proto指向Person.prototype完成对原型的属性和方法的继承； Person.call(o,name)这里即函数Person作为apply/call调用(具体内容下方)，将Person对象里的this改为o，即完成了o.name = name操作； 返回对象o。 因此person(&quot;xl&quot;)返回了一个继承了Person.prototype对象上的属性和方法，以及拥有name属性为&quot;xl&quot;的对象，并将它赋给变量personB，所以console.log(personB.name)会输出&quot;xl&quot; call/apply方法的调用在JS里，函数也是对象，因此函数也有方法。从Function.prototype上继承到Function.prototype.call/Function.prototype.apply方法call/apply方法最大的作用就是能改变this关键字的指向.Obj.method.apply(AnotherObj, arguments); 12345678910var name = \"XL\";var Person = &#123; name: \"xl\", showName: function()&#123; console.log(this.name); &#125;&#125;Person.showName.call(); //输出 \"XL\"//这里call方法里面的第一个参数为空，默认指向window。//虽然showName方法定义在Person对象里面，但是使用call方法后，将showName方法里面的this指向了window。因此最后会输出\"XL\"; 123456789101112131415161718funtion FruitA(n1,n2)&#123; this.n1 = n1; this.n2 = n2; this.change = function(x, y)&#123; this.n1 = x; this.n2 = y; &#125;&#125;var fruitA = new FruitA(\"cheery\",\"banana\");var FruitB = &#123; n1: \"apple\", n2: \"orange\"&#125;;fruitA.change.call(FruitB,\"pear\",\"peach\");console.log(FruitB.n1); //输出 pearconsole.log(FruitB.n2);// 输出 peach FruitB调用fruitA的change方法，将fruitA中的this绑定到对象FruitB上。 Function.prototype.bind()方法1234567891011var name = \"XL\";function Person(name)&#123; this.name = name; this.sayName = function()&#123; setTimeout(function()&#123; console.log(\"my name is \"+this.name); &#125;,50) &#125;&#125;var person = new Person(\"xl\");person.sayName() //输出 “my name is XL”; 那么如何才能输出&quot;my name is xl&quot;呢？ 1234567891011var name = \"XL\";function Person(name)&#123; this.name = name; this.sayName = function()&#123; setTimeout(function()&#123; console.log(\"my name is \"+this.name); &#125;.bind(this),50) //注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象 &#125;&#125;var person = new Person(\"xl\");person.sayName(); //输出 “my name is xl”; 这里setTimeout(function(){console.log(this.name)}.bind(this),50);，匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向的Person，而非window，因此最后的输出为&quot;my name is xl&quot;而不是&quot;my name is XL&quot; 另外几个需要注意的地方： setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。在《javascript高级程序设计》当中，写到：“超时调用的代码(setTimeout)都是在全局作用域中执行的，因此函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined”。本文都是在非严格模式下的情况。 123456789101112var name = \"XL\";function Person()&#123; this.name = \"xl\"; this.showName = function()&#123; console.log(this.name); &#125; setTimeout(this.showName,50);&#125;var person = new Person(); //输出 \"XL\"//在setTimeout(this.showName,50)语句中，会延时执行this.showName方法//this.showName方法即构造函数Person()里面定义的方法。50ms后，执行this.showName方法，this.showName里面的this此时便指向了window对象。则会输出\"XL\"; 修改上面的代码： 1234567891011var name = \"XL\";function Person()&#123; this.name = \"xl\"; var that = this; this.showName = function()&#123; console.log(that.name); &#125; setTimeout(this.showName,50)&#125;var person = new Person(); //输出 \"xl\"//这里在Person函数当中将this赋值给that，即让that保存Person对象，因此在setTimeout(this.showName,50)执行过程当中，console.log(that.name)即会输出Person对象的属性\"xl\" 匿名函数： 12345678910111213var name = \"XL\";var person = &#123; name: \"xl\", showName: function()&#123; console.log(this.name); &#125; sayName: function()&#123; (function(callback)&#123; callback(); &#125;)(this.showName) &#125;&#125;person.sayName(); //输出 XL 123456789101112131415var name = \"XL\";var person = &#123; name: \"xl\", showName: function()&#123; console.log(this.name); &#125; sayName: function()&#123; var that = this; (function(callback)&#123; callback(); &#125;)(that.showName) &#125;&#125;person.sayName() ; //输出 \"xl\"//匿名函数的执行同样在默认情况下this是指向window的，除非手动改变this的绑定对象 Eval函数该函数执行的时候，this绑定到当前作用域的对象上 123456789101112var name = \"XL\";var person = &#123; name: \"xl\", showName: function()&#123; eval(\"console.log(this.name)\"); &#125;&#125;person.showName(); //输出 \"xl\"var a=person.showName;a(); //输出 \"XL\" 参考自： 详解this javascript中this详解 深入浅出javascript中的this setTimeout中this的指向问题 Javascript的this用法 转自：JS 中 this 关键字详解","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"this","slug":"this","permalink":"http://007sair.github.io/tags/this/"}]},{"title":"Javascript中对象、原型、继承详解","slug":"js-prototype","date":"2015-07-21T16:00:00.000Z","updated":"2018-07-26T07:08:26.509Z","comments":true,"path":"2015/07/22/js-prototype/","link":"","permalink":"http://007sair.github.io/2015/07/22/js-prototype/","excerpt":"对象对象分普通对象和函数对象，Object、Function是js自带的函数对象。","text":"对象对象分普通对象和函数对象，Object、Function是js自带的函数对象。 12345678910111213141516function f1()&#123;&#125;;var f2 = function()&#123;&#125;;var f3 = new Function('str','console.log(str)');var o3 = new f1();var o1 = &#123;&#125;;var o2 = new Object();console.log(typeof Object); //functionconsole.log(typeof Function); //functionconsole.log(typeof o1); //objectconsole.log(typeof o2); //objectconsole.log(typeof o3); //objectconsole.log(typeof f1); //functionconsole.log(typeof f2); //functionconsole.log(typeof f3); //function 以上例子说明：凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。 Function、Object 也都是通过new Function()创建的。 原型js中所有的函数都有一个prototype属性，这个属性引用了一个对象，即原型对象，也简称原型。这个_函数_包括构造函数和普通函数，我们讲的更多是构造函数的原型，但是也不能否定普通函数也有原型。 注：普通对象没有prototype属性，但有内置属性：__proto__（可以在chrome中查看该属性，但不要依赖使用此属性）。 譬如普通函数： 1234function f()&#123; //...&#125;alert(f.prototype instanceof Object) //true 构造函数，也叫构造对象。首先了解下通过构造函数实例化对象的过程。 1234function A(x)&#123; this.x=x;&#125;var a = new A(1); newnew也就是实例化对象，过程有如下几步： 创建对象o;var o = {}; 将o内部的__proto__对象的引用指向o的构造函数A的原型对象（A.prototype）。 将o作为this去调用构造函数A，从而设置o的属性和方法并初始化。 传送门：模拟new操作符的内部处理过程 当这3步完成，这个o对象就与构造函数A再无联系，这个时候即使构造函数A再加任何成员，都不再影响已经实例化的o对象了。此时，o对象具有了x属性，同时具有了构造函数A的原型对象的所有成员，当然，此时该原型对象是没有成员的。 原型对象初始是空的，也就是没有一个成员（即原型属性和原型方法）。可以通过如下方法验证原型对象具有多少成员。 12345678910111213141516function A(name)&#123; this.name = name;&#125;var num = 0;A.prototype.say = function()&#123; alert(\"Hi\")&#125;;for(i in A.prototype)&#123; console.log(i); //say num++;&#125;console.log(\"member: \" + num); // 1 解释了什么是原型对象，我们再来看看它的作用是什么，先看一段代码： 12345678function Person(name)&#123; this.name = name;&#125;Person.prototype.getName = function()&#123; return this.name;&#125;var o = new Person('chan');o.getName(); // chan 可以看到，通过给Person.prototype设置一个方法getName，实例后的对象o也会继承这个方法。具体怎么实现的继承，需讲到下面的原型链。 原型链js在创建对象（无论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。 原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 简单回顾下构造函数、原型和实例的关系： 每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针（prototype），而实例则包含一个指向原型对象的内部指针（__proto__）。 以下面的例子为例： 12345678910function Person(name)&#123; this.name = name;&#125;Person.prototype.getName = function()&#123; return this.name;&#125;var o = new Person('chan');o.getName(); // chanconsole.log(o.__proto__ === Person.prototype) //true Person.prototype对象也有__proto__属性，它指向创建它的函数对象（Object）的 prototype： 1console.log(Person.prototype.__proto__ === Object.prototype) //true 继续，Object.prototype对象也有__proto__属性，但它比较特殊，为null 1console.log(Object.prototype.__proto__) //null 原型链如下图： 疑点解释：12345Object.__proto__ === Function.prototype // true Object是函数对象，是通过new Function()创建，所以Object.__proto__指向Function.prototype。Function.__proto__ === Function.prototype // true Function 也是对象函数，也是通过new Function()创建，所以Function.__proto__指向Function.prototype。Function.prototype.__proto__ === Object.prototype //true Function.prototype是个函数对象，理论上他的__proto__应该指向 Function.prototype，就是他自己，自己指向自己，没有意义。 js一切皆为对象，原型链的最顶层为null，即Object.prototype.__proto__ === null instanceof12345//demo[1,2] instanceof Array //truenew Object() instanceof Array //false[1,2] instanceof Object //true 左侧一般是一个对象，右侧一定是个函数对象，不是函数对象会报错。 原理：右侧函数的prototype属性是否出现在左侧对象的原型链上。即：左侧的原型链上是否有右侧的原型。 constructor原型对象prototype中都有预定义的constructor，用来指向它的构造函数。 123o.prototype.constructor === Person //trueFunction.prototype.constructor === Function //trueObject.prototype.constructor === Object //true 继承因为ECMAscript的发明者为了简化这门语言，同时又保持继承性，采用了链式继承的方法。 由构造函数创建的每个实例都有个__proto__属性，它指向构造函数的prototype。那么构造函数的prototype上定义的属性和方法都会被instance所继承. 12345678910111213141516171819202122232425function Person()&#123; //...&#125;function Student()&#123; //...&#125;Student.prototype = Person.prototype; //不可以这样继承，改变Student的同时，也会改变Person，因为他们是引用Student.prototype = new Person(); //可以实现 new Person的时候得到了Person的实例，并且Person的实例指向了Person.prototype 并且调用了构造函数。不过因为调用了构造函数，在Person有参数时此方法不太好使//仅ES5+支持Student.prototype = Object.create(Person.prototype); //Object.create的作用：创建以个空对象，并且这个空对象的原型指向传入的参数，即Person.prototypeStudent.prototype.constructor = Person;if(!Object.create)&#123; //proto 为原型对象 Object.create = function(proto)&#123; function F()&#123;&#125;; F.prototype = proto; return new F; &#125;&#125; 参考自： JS原型与原型链终极详解 JavaScript探秘：强大的原型和原型链 js原型链看图说明 理解javascript原型 javascript类和继承:constructor javascript探秘:构造函数","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"},{"name":"原型","slug":"原型","permalink":"http://007sair.github.io/tags/原型/"}]},{"title":"SASS笔记","slug":"sass-study","date":"2014-12-10T16:00:00.000Z","updated":"2018-07-26T07:08:26.509Z","comments":true,"path":"2014/12/11/sass-study/","link":"","permalink":"http://007sair.github.io/2014/12/11/sass-study/","excerpt":"变量变量通过$命名，属性和值中间用:赋值。 规则： 作用域：作用域同javascript，想调用局部变量可在值后使用 !global 默认值：变量没有设置具体值时，使用 !default","text":"变量变量通过$命名，属性和值中间用:赋值。 规则： 作用域：作用域同javascript，想调用局部变量可在值后使用 !global 默认值：变量没有设置具体值时，使用 !default 12345678910111213//demo$primaryColor: #eeccff;$firstValue: 62.5%;$firstValue: 24px !default;body &#123; $primaryColor: #ccc; background: $primaryColor; //编译后#ccc font-size: $firstValue; //编译后62.5%;&#125;p &#123; color: $primaryColor; //编译后#eeccff&#125; 插值：变量除了作为属性值使用，还能用在选择器或者属性名上： 1234567891011121314151617//scss$out: margin;$in: padding;.#&#123;$out&#125;-div &#123; #&#123;$out&#125;-top : 10px;&#125;.#&#123;$in&#125;-div &#123; #&#123;$in&#125;-top : 10px;&#125;//css.margin-div &#123; margin-top: 10px;&#125;.padding-div &#123; padding-top: 10px;&#125; 引用@import语法格式如下： 123@import \"reset.scss\";//or@import \"reset\"; 引用的scss文件会被自动编译成对应的css文件。如：reset.scss会被自动编译成 reset.css，解决这个问题可以给reset.scss文件名重命名为：_reset.scss。当然，import的引用里不需要加_。 注释sass共有两种注释和一种特殊注释： /*...*/ 这种注释会保留到编译后的css文件中； //... 这种注释只保留在sass中，不会被编译至css。 /*! ... */ 这种注释多了个感叹号，表示为重要注释，即使是压缩模式，也会保留这行注释，通常用于声明版权信息。 嵌套选择器嵌套123456789div &#123; h1 &#123; color: #f00; &#125;&#125;//或者：div h1 &#123; color: #f00&#125; 属性嵌套属性嵌套可以用在单属性和复合属性的嵌套中： 12345678910111213//scssdiv &#123; border: &#123; //注意border后面的冒号 color: #ccc; style: solid; &#125;&#125;//cssdiv &#123; border-color: #ccc; border-style: solid;&#125; &amp;引用父选择器可以通过 &amp; 符号实现： 123456789101112131415161718192021//scssa.myAnchor &#123; color: blue; &amp;:hover &#123; text-decoration: underline; &#125; &amp;:visited &#123; color: purple; &#125;&#125;//cssa.myAnchor &#123; color: blue;&#125;a.myAnchor:hover &#123; text-decoration: underline;&#125;a.myAnchor:visited &#123; color: purple;&#125; @at-root离开嵌套回到顶层（根级）选择器，那么我们可以使用 @at-root 指令 12345678910111213141516171819202122232425262728293031//scss.first-component &#123; .text &#123; font-size: 1.4rem; &#125; .button &#123; font-size: 1.7rem; &#125; @at-root .second-component &#123; .text &#123; font-size: 1.2rem; &#125; .button &#123; font-size: 1.4rem; &#125; &#125;&#125;//css.first-component .text &#123; font-size: 1.4rem;&#125;.first-component .button &#123; font-size: 1.7rem;&#125;.second-component .text &#123; font-size: 1.2rem;&#125;.second-component .button &#123; font-size: 1.4rem;&#125; Inception Rule：选择器深度不要超过四层。——thesassway 继承@extend使用@extend指令扩展input类，指向input-error类 1234567891011121314//scss.input &#123; border-radius: 3px; border: 4px solid #ddd; color: #555; font-size: 17px; padding: 10px 20px; display: inline-block; outline: 0;&#125;.error-input &#123; @extend .input; border:4px solid #e74c3c;&#125; 请注意：这么做并不会从.input复制样式到.error-input中。 编译后如下： 1234567891011121314151617/*css*/.input, .error-input &#123; border-radius: 3px; border: 4px solid #ddd; color: #555; font-size: 17px; padding: 10px 20px; display: inline-block; outline: 0;&#125;.error-input &#123; border: 4px solid #e74c3c;&#125;body &#123; text-align: center; padding-top: 100px;&#125; 占位选择器%从sass 3.2.0以后就可以定义占位选择器%。这种选择器的优势在于：如果不调用则不会有任何多余的css文件，避免了以前在一些基础的文件中预定义了很多基础的样式，然后实际应用中不管是否使用了@extend去继承相应的样式，都会解析出来所有的样式。占位选择器以%标识定义，通过@extend调用。 123456789101112131415161718192021222324252627282930313233//scss%mod-input &#123; border-radius: 3px; color: #555; font-size: 17px; padding: 10px 20px; display: inline-block; outline: 0;&#125;.input &#123; @extend %mod-input; border: 4px solid #ddd;&#125;.input-error &#123; @extend %mod-input; border:4px solid #e74c3c;&#125;//css.input, .input-error &#123; border-radius: 3px; color: #555; font-size: 17px; padding: 10px 20px; display: inline-block; outline: 0;&#125;.input &#123; border: 4px solid #ddd;&#125;.input-error &#123; border: 4px solid #e74c3c;&#125; 混合sass中使用@mixin声明混合，可以传递参数，参数名以$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的@mixin通过@include来调用。 无参数mixin1234567891011121314//scss@mixin center-block &#123; margin-left:auto; margin-right:auto;&#125;.demo &#123; @include center-block;&#125;//css.demo &#123; margin-left:auto; margin-right:auto;&#125; 有参数mixin12345678910111213//scss@mixin opacity($opacity:50) &#123; opacity: $opacity / 100; filter: alpha(opacity=$opacity);&#125;//css.opacity &#123; @include opacity; //参数使用默认值&#125;.opacity-80 &#123; @include opacity(80); //传递参数&#125; 多个参数mixin调用时可直接传入值，如@include传入参数的个数小于@mixin定义参数的个数，则按照顺序表示，后面不足的使用默认值，如不足的没有默认值则报错。除此之外还可以选择性的传入参数，使用参数名与值同时传入。 123456789101112131415161718192021222324//scss@mixin horizontal-line($border:1px dashed #ccc, $padding:10px) &#123; border-bottom:$border; padding-top:$padding; padding-bottom:$padding; &#125;.imgtext-h li &#123; @include horizontal-line(1px solid #ccc);&#125;.imgtext-h--product li &#123; @include horizontal-line($padding:15px);&#125;//css.imgtext-h li &#123; border-bottom: 1px solid #cccccc; padding-top: 10px; padding-bottom: 10px;&#125;.imgtext-h--product li &#123; border-bottom: 1px dashed #cccccc; padding-top: 15px; padding-bottom: 15px;&#125; 多组值参数mixin如果一个参数可以有多组值，如box-shadow、transition等，那么参数则需要在变量后加三个点表示，如$variables...。 1234567891011121314151617//scss//box-shadow可以有多组值，所以在变量参数后面添加...@mixin box-shadow($shadow...) &#123; -webkit-box-shadow:$shadow; box-shadow:$shadow;&#125;.box &#123; border:1px solid #ccc; @include box-shadow(0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3));&#125;//css.box &#123; border:1px solid #ccc; -webkit-box-shadow:0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3); box-shadow:0 2px 2px rgba(0,0,0,.3),0 3px 3px rgba(0,0,0,.3),0 4px 4px rgba(0,0,0,.3);&#125; @content@content在sass3.2.0中引入，可以用来解决css3的@media等带来的问题。它可以使@mixin接受一整块样式，接受的样式从@content开始。 123@mixin media($queryString) &#123; //...&#125; 注意我们在混合宏media中声明了一个$queryString参数。当我们引入混合宏时，可以一个字符串参数以实现动态渲染。 12345@mixin media($queryString) &#123; @media #&#123;$queryString&#125; &#123; @content; &#125;&#125; 因为我们期待字符串参数被目标函数使用，所以使用了Sass的插值语法，#{}。当你传递变量到这个括号中时，变量会像字符串一样输出而不是进行某种逻辑运算。这个例子中另一个生疏的地方是@content指令。当你使用的混合宏后接被大括号包裹的样式，那么被包裹样式就可以通过@content指令加以使用。 12345678910111213141516171819202122//scss@mixin media($queryString) &#123; @media #&#123;$queryString&#125; &#123; @content; &#125;&#125;.container &#123; width: 900px; @include media(\"(max-width: 767px)\") &#123; width: 100%; &#125;&#125;//css.container &#123; width: 900px;&#125;@media (max-width: 767px) &#123; .container&#123; width: 100%; &#125;&#125; 使用@content的好处：在需要Media Queries的地方，可以快速插入，而不需要在专门的区域重新定义。 PS： @mixin通过@include调用后解析出来的样式是以拷贝形式存在的，而下面的继承则是以联合声明的方式存在的，所以从3.2.0版本以后，建议传递参数的用@mixin，而非传递参数类的使用下面的继承%。 函数官方列表：sass function 在Sass中，函数指令类似于混合宏，sass默认已有很多函数，定义函数的方式以@function它们会通过@return指令返回值而不是返回样式。这可以降低代码中的重复率并提高可读性。 123456789101112131415161718192021222324252627//scss$baseFontSize: 10px !default;$gray: #ccc !default; // pixels to rems @function pxToRem($px) &#123; @return $px / $baseFontSize * 1rem;&#125;body &#123; font-size:$baseFontSize; color:lighten($gray,10%);&#125;.test &#123; font-size:pxToRem(16px); color:darken($gray,10%);&#125;//cssbody &#123; font-size: 10px; color: #e6e6e6;&#125;.test &#123; font-size: 1.6rem; color: #b3b3b3;&#125; 演示demo 关于@mixin、%、@function更多可参考： sass揭秘之@mixin，%，@function Sass基础——颜色函数 Sass基础——Sass函数 运算sass可以使用各种算式进行值的计算： 1234567891011121314//scss$num : 2;body &#123; margin: (14px/2); top: 50px + 100px; right: $num * 10%;&#125;//cssbody &#123; margin: 7px; top: 150px; right: 20%;&#125; 加法加法运算不仅仅是数字计算，也可以像js一样连接字符串。 123456789//scssp &#123; text-decoration: line + -through;&#125;//cssp &#123; text-decoration: line-through;&#125; 加法连接字符串也有一定的规则：如果前面字符串带有引号，后面字符串会自动包含在引号中，如果前面没有，后面带有引号的字符串也会去掉引号： 1234567891011//scssp:before &#123; content: \"Foo \" + Bar; font-family: sans- + \"serif\";&#125;//cssp:before &#123; content: \"Foo Bar\"; font-family: sans-serif;&#125; 运算时会以空格作为分割，会操作相邻的两个数值，如： 123456789//scssp &#123; margin: 3px + 4px auto;&#125;//cssp &#123; margin: 7px auto;&#125; 插值运算#{}在字符串中的使用： 12345678910//scss$w : 10;p:before &#123; content: \"I ate #&#123;5 + $w&#125; pies!\";&#125;//cssp:before &#123; content: \"I ate 15 pies!\";&#125; 除法除法也有很多需要注意的地方，因为除法的运算符 / 在 CSS 中也有遇到，例如font缩写属性时候的font-size和line-height属性，就需要 / 来分割。所以，在这些包含 / 的 CSS 属性中对应位置的值，是不会参与运算的，除了下面情况下： 如果两个值其中一个或两个存放在变量中或者是由函数返回的值； // $num / 2 or rem(40) / 2 如果值被包裹在一对括号里面； // (12px/2) 如果值被作为另一个表达式的一部分。 // 10px + 15px/2 123456789101112131415161718//scssp &#123; font: 10px / 8px; // 纯 CSS 不会运算 $width: 1000px; width: $width / 2; // 使用变量，执行运算 width: round(1.5) / 2; // 使用函数返回值，执行运算 height: (500px / 2); // 使用括号包裹，执行运算 margin-left: 5px + 8px / 2px; // 用了加法，作为表达式的一部分，执行运算&#125;//cssp &#123; font: 10px / 8px; width: 500px; width: 1; height: 250px; margin-left: 9px;&#125; 注意事项： 1.运算符的两边最好保留空格。 123456//scss$w : 7px;$h : 10px;p:before &#123; width: $h - $w; // 报错：Undefined variable: \"$h-\".&#125; 2.运算单位不要混合使用。 1234$num : 10px;div &#123; margin: $num * 20%; //报错：200%*px isn't a valid CSS value.&#125; 总的运算规则如下： 加法：都没有单位输出纯数字；一方有单位，则结果输出该单位；两方相同单位，结果输出该单位；双方单位不同，报错。 减法：类似加法。 除法：两方相同单位，结果无单位；都没有单位，结果无单位；一方有单位另一方无单位，报错。 乘法：两方相同单位，报错；一方有单位，结果输出该单位；两方都无单位，输出无单位。 控制语句@if@if作为判断语句，除了判断真假，还能判断或（or）、非（not）、与（and）、等于（==）、不等于（!=） 123456789101112131415161718192021222324//inline-block@mixin inline-block($lte7:true) &#123; display: inline-block; @if $lte7&#123; *display: inline; *zoom:1; &#125;&#125;.div1 &#123; @include inline-block();&#125;.div2 &#123; @include inline-block(false);&#125;//css.div1 &#123; display: inline-block; *display: inline; *zoom: 1;&#125;.div2 &#123; display: inline-block;&#125; 三目运算： 语法为：if($condition, $if_true, $if_false)，三个参数分别表示：条件，条件为真的值，条件为假的值。 12345678910//scss$fontBold: true;.title &#123; font-weight: if($fontBold, bold, normal);&#125;//css.title &#123; font-weight: bold;&#125; @for语法：@for $i from start through end 或 @for $i from start to end，$i表示要循环的变量，start为起始值，end为结束值。唯一区别为through表示包含结束值，to则表示不包含结束值。 1234567891011121314151617181920212223//scss@for $i from 1 through 5 &#123; .div#&#123;$i&#125; &#123; background: url(images/bg#&#123;$i&#125;.jpg); &#125;&#125;//css.div1 &#123; background: url(images/bg1.jpg);&#125;.div2 &#123; background: url(images/bg2.jpg);&#125;.div3 &#123; background: url(images/bg3.jpg);&#125;.div4 &#123; background: url(images/bg4.jpg);&#125;.div5 &#123; background: url(images/bg5.jpg);&#125; @for语句有两种： @for $i from 1 through 5，through表示包含5 @for $i from 1 to 5， to则反之 @each语法：@each $i in a, b, c，具体实现看如下demo： 123456789101112131415161718192021222324//scss$icons : tag, name, cut, tel, num;@each $i in $icons &#123; //或者： @each $i in tag, name, cut, tel, num&#123;&#125; .icon-#&#123;$i&#125; &#123; background-img: url(images/icon-#&#123;$i&#125;.png); &#125;&#125;//css.icon-tag &#123; background-img: url(images/icon-tag.png);&#125;.icon-name &#123; background-img: url(images/icon-name.png);&#125;.icon-cut &#123; background-img: url(images/icon-cut.png);&#125;.icon-tel &#123; background-img: url(images/icon-tel.png);&#125;.icon-num &#123; background-img: url(images/icon-num.png);&#125; 一个经典循环 css sprite 的做法： 1234567891011121314151617181920212223242526272829//scss$sprite: puma sea-slug egret salamander !default;%sprite-animal &#123; background: url('/images/animal.png') no-repeat;&#125;@each $animal in $sprite &#123; .#&#123;$animal&#125;-icon &#123; @extend %sprite-animal; background-position:0 -(index($sprite,$animal)*30px); &#125;&#125;//css.puma-icon, .sea-slug-icon, .egret-icon, .salamander-icon &#123; background: url(\"/images/animal.png\") no-repeat;&#125;.puma-icon &#123; background-position: -30px;&#125;.sea-slug-icon &#123; background-position: -60px;&#125;.egret-icon &#123; background-position: -90px;&#125;.salamander-icon &#123; background-position: -120px;&#125; @while@while和@for循环非常相似，不过@while可以控制循环步数。 1234567891011121314151617//scss$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125;&#123; width: 2em * $i; &#125; $i: $i - 2;&#125;//css.item-6 &#123; width: 12em;&#125;.item-4 &#123; width: 8em;&#125;.item-2 &#123; width: 4em;&#125; sass相关工具推荐 sass在线编译 sass可视化编译工具: Koala","categories":[{"name":"sass","slug":"sass","permalink":"http://007sair.github.io/categories/sass/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"sass","slug":"sass","permalink":"http://007sair.github.io/tags/sass/"}]},{"title":"css巧妙实现分隔线","slug":"css-hr","date":"2014-12-07T16:00:00.000Z","updated":"2018-07-26T07:08:26.509Z","comments":true,"path":"2014/12/08/css-hr/","link":"","permalink":"http://007sair.github.io/2014/12/08/css-hr/","excerpt":"单个标签实现分隔线12345678.demo_line_01&#123; padding: 0 20px 0; margin: 20px 0; line-height: 1px; border-left: 200px solid #ddd; border-right: 200px solid #ddd; text-align: center;&#125;","text":"单个标签实现分隔线12345678.demo_line_01&#123; padding: 0 20px 0; margin: 20px 0; line-height: 1px; border-left: 200px solid #ddd; border-right: 200px solid #ddd; text-align: center;&#125; 优点：代码简洁 背景色实现分隔线1234567891011.demo_line_02&#123; height: 1px; border-top: 1px solid #ddd; text-align: center;&#125;.demo_line_02 span&#123; position: relative; top: -8px; background: #fff; padding: 0 20px;&#125; 优点：代码简洁，可自适应宽度 inline-block实现分隔线1234567891011121314151617.demo_line_03&#123; width:600px;&#125;.demo_line_03 b&#123; background: #ddd; margin-top: 4px; display: inline-block; width: 180px; height: 1px; _overflow: hidden; vertical-align: middle;&#125;.demo_line_03 span&#123; display: inline-block; width: 220px; vertical-align: middle;&#125; 优点：文字可多行 浮动实现分隔线123456789101112131415.demo_line_04&#123; width:600px;&#125;.demo_line_04&#123; overflow: hidden; _zoom: 1;&#125;.demo_line_04 b&#123; background: #ddd; margin-top: 8px; float: left; width: 26%; height: 1px; _overflow: hidden;&#125; 利用字符实现分隔线1&lt;div class=\"demo_line_05\"&gt;———————————&lt;span&gt;小小分隔线 字符来实现&lt;/span&gt;————————————&lt;/div&gt; 123456789.demo_line_05&#123; letter-spacing: -1px; color: #ddd;&#125;.demo_line_05 span&#123; letter-spacing: 0; color: #222; margin:0 20px;&#125; 优点：代码简洁 以上转自大前端：http://www.daqianduan.com/4258.html 还有一种利用fieldset标签实现的方法：html: 12345678&lt;form class=\"form\"&gt; &lt;fieldset class=\"fieldset\"&gt; &lt;legend class=\"legend\"&gt;&lt;a href=\"#\"&gt;可能感兴趣的人&lt;/a&gt;&lt;/legend&gt; &lt;div class=\"btns\"&gt; &lt;a href=\"#\"&gt;更多&lt;/a&gt;&lt;a href=\"#\"&gt;111&lt;/a&gt; &lt;/div&gt; &lt;/fieldset&gt;&lt;/form&gt; css: 12345.form&#123; margin:10px auto; width:800px&#125;.fieldset&#123; border-width:1px 0 0; border-color:#ccc; border-style:solid; padding-left:30px;&#125;.legend&#123; padding:0 5px;&#125;.btns&#123; padding:0 5px; float:right; margin:-18px 10px 0 0; background:#fff; _position:relative &#125;.btns a&#123; border-radius:5px; border:1px solid #CCC; padding:3px 7px; margin:0 2px; background:#fff; display:inline-block;&#125; DEMO","categories":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"}]},{"title":"css的兼容解决方法","slug":"csshack","date":"2014-11-02T16:00:00.000Z","updated":"2018-07-26T07:08:26.509Z","comments":true,"path":"2014/11/03/csshack/","link":"","permalink":"http://007sair.github.io/2014/11/03/csshack/","excerpt":"推荐几种css兼容的方法，一般用在IE中。 第一种(不推荐)：将当前页面使用IE7进行渲染 123&lt;meta http-equiv=\"x-ua-compatible\" content=\"ie=7\" /&gt;&lt;!-- 或者 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\"content=\"IE=EmulateIE7\" /&gt;","text":"推荐几种css兼容的方法，一般用在IE中。 第一种(不推荐)：将当前页面使用IE7进行渲染 123&lt;meta http-equiv=\"x-ua-compatible\" content=\"ie=7\" /&gt;&lt;!-- 或者 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\"content=\"IE=EmulateIE7\" /&gt; 前提：页面头部加meta的时候请注意w3c的标准，如下为示范: 12&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt; 第二种方法:不添加头部代码，只通过修改css的样式解决兼容问题。以下顺序不能颠倒！ 123456margin-bottom: 40px; /* all属性 */[color: #000000;color: #00FF00; /* SF,CH支持 */margin-bottom: 140px\\9; /* IE6-10 11未测试 */margin-bottom: 140px\\0; /* IE8-10 11未测试 */*margin-bottom: 450px; /* IE6/7的属性*/ _margin-bottom: 450px; /* IE6的属性 */ PS：值和识别符(\\0、\\9等)之间不能有空格 12345678910111213141516171819202122232425262728/* All IE */div &#123; property:value\\9; &#125; /*所有的IE都支持*/ /* IE9（含IE9）以上的浏览器支持 */:root .a &#123; background: #f00;&#125;:root .a &#123; background: #f00\\9;&#125;:root .a &#123; background: #f00\\0;&#125;:root .a &#123; background: #f00\\0\\9;&#125;:root .a &#123; background: #f00\\9\\0;&#125;/* IE8（含IE8）以上的浏览器支持*/.test &#123; property:value\\0; &#125;.test &#123; property:value\\0\\9; &#125;.test &#123; property:value\\9\\0; &#125;/* 仅IE8 */.test &#123; property:value\\0/; &#125;/* IE7（含IE7）以下的浏览器支持*/.test &#123; *property:value; &#125; .test &#123; +property:value; &#125;/* IE6 */.test &#123; _property:value; &#125;.test &#123; -property:value; &#125;/* 非 IE */.test &#123; property//:value; &#125; IE9-CSSHACK另外写法： 12345#element &#123; color:orange;&#125;#element &#123; *color: white;&#125; /* IE6+7, doesn't work in IE8/9 as IE7 */#element &#123; _color: red; &#125; /* IE6 */#element &#123; color: green\\0/;&#125; /* IE8 */:root #element &#123; color:pink\\0/;&#125; /* IE9 */ 注释使用： 123&lt;!--[if IE 6]&gt; .....&lt;![endif]--&gt; if IE起着非常大的作用！ if IE什么意思呢？下面就列举了一些在CSS常见的HACK控制语句。 作为IE的IF条件注释使用备忘，有些时候试用if IE而不是在css中使用hack，就能通过w3c验证。 一些常用注释： 1234567891011&lt;!--[if !IE]&gt;除IE外都可识别&lt;![endif]--&gt;&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt;!--[if IE 5.0]&gt; 只有IE5.0可以识别 &lt;![endif]--&gt;&lt;!--[if IE 5]&gt; 仅IE5.0与IE5.5可以识别 &lt;![endif]--&gt;&lt;!--[if gt IE 5.0]&gt; IE5.0以及IE5.0以上版本都可以识别 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt; lte：就是Less than or equal to的简写，也就是小于或等于的意思。 lt ：就是Less than的简写，也就是小于的意思。 gte：就是Greater than or equal to的简写，也就是大于或等于的意思。 gt：就是Greater than的简写，也就是大于的意思。 !?：就是不等于的意思，跟javascript里的不等于判断符相同 需要注意的是：IE7对样式的解释跟DTD是有关，在没有DTD的时候，IE7是能读取IE6的hack的。 注： IE6能识别*，但不能识别!important, IE7能识别*，也能识别!important; FF不能识别*，但能识别!important; IE6 IE7 FF * √ √ × !important × √ √ _ √ × × 另外再补充一个，下划线”_”,IE6支持下划线，IE7和firefox均不支持下划线。(推荐) 于是大家还可以这样来区分IE6，IE7，firefox : background:orange; *background:green; _background:blue;","categories":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"}]},{"title":"有用的CSS代码片段","slug":"css-usefull","date":"2014-08-03T16:00:00.000Z","updated":"2018-07-26T07:08:26.508Z","comments":true,"path":"2014/08/04/css-usefull/","link":"","permalink":"http://007sair.github.io/2014/08/04/css-usefull/","excerpt":"1、css重置Normalize.css与传统的css Reset的区别：http://jerryzou.com/posts/aboutNormalizeCss/ 2、clearfix123.clearfix:before, .container:after &#123; content: \"\"; display: table; &#125;.clearfix:after &#123; clear: both; &#125;.clearfix &#123; zoom: 1; &#125; /* IE 6/7 */","text":"1、css重置Normalize.css与传统的css Reset的区别：http://jerryzou.com/posts/aboutNormalizeCss/ 2、clearfix123.clearfix:before, .container:after &#123; content: \"\"; display: table; &#125;.clearfix:after &#123; clear: both; &#125;.clearfix &#123; zoom: 1; &#125; /* IE 6/7 */ 3、css块引用模版123456789101112131415161718blockquote &#123; background: #f9f9f9; border-left: 10px solid #ccc; margin: 1.5em 10px; padding: 0.5em 10px; quotes: \"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\";&#125;blockquote:before &#123; color: #ccc; content: open-quote; font-size: 4em; line-height: 0.1em; margin-right: 0.25em; vertical-align: -0.4em;&#125;blockquote p &#123; display: inline;&#125; 4、媒体查询12345678910111213141516171819202122232425262728293031323334353637/* Smartphones (portrait and landscape) ----------- */@media only screenand (min-device-width : 320px) and (max-device-width : 480px) &#123; /* Styles */&#125;/* Smartphones (landscape) ----------- */@media only screen and (min-width : 321px) &#123; /* Styles */&#125;/* Smartphones (portrait) ----------- */@media only screen and (max-width : 320px) &#123; /* Styles */&#125;/* iPads (portrait and landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) &#123; /* Styles */&#125;/* iPads (landscape) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) &#123; /* Styles */&#125;/* iPads (portrait) ----------- */@media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) &#123; /* Styles */&#125;/* Desktops and laptops ----------- */@media only screen and (min-width : 1224px) &#123; /* Styles */&#125;/* Large screens ----------- */@media only screen and (min-width : 1824px) &#123; /* Styles */&#125;/* iPhone 4 ----------- */@media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) &#123; /* Styles */&#125; 5、现代字体栈1234567891011121314151617181920212223/* Times New Roman-based serif */font-family: Cambria, \"Hoefler Text\", Utopia, \"Liberation Serif\", \"Nimbus Roman No9 L Regular\", Times, \"Times New Roman\", serif; /* A modern Georgia-based serif */font-family: Constantia, \"Lucida Bright\", Lucidabright, \"Lucida Serif\", Lucida, \"DejaVu Serif,\" \"Bitstream Vera Serif\", \"Liberation Serif\", Georgia, serif; /*A more traditional Garamond-based serif */font-family: \"Palatino Linotype\", Palatino, Palladio, \"URW Palladio L\", \"Book Antiqua\", Baskerville, \"Bookman Old Style\", \"Bitstream Charter\", \"Nimbus Roman No9 L\", Garamond, \"Apple Garamond\", \"ITC Garamond Narrow\", \"New Century Schoolbook\", \"Century Schoolbook\", \"Century Schoolbook L\", Georgia, serif; /*The Helvetica/Arial-based sans serif */font-family: Frutiger, \"Frutiger Linotype\", Univers, Calibri, \"Gill Sans\", \"Gill Sans MT\", \"Myriad Pro\", Myriad, \"DejaVu Sans Condensed\", \"Liberation Sans\", \"Nimbus Sans L\", Tahoma, Geneva, \"Helvetica Neue\", Helvetica, Arial, sans-serif; /*The Verdana-based sans serif */font-family: Corbel, \"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Liberation Sans\", Verdana, \"Verdana Ref\", sans-serif; /*The Trebuchet-based sans serif */font-family: \"Segoe UI\", Candara, \"Bitstream Vera Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Trebuchet MS\", Verdana, \"Verdana Ref\", sans-serif; /*The heavier \"Impact\" sans serif */font-family: Impact, Haettenschweiler, \"Franklin Gothic Bold\", Charcoal, \"Helvetica Inserat\", \"Bitstream Vera Sans Bold\", \"Arial Black\", sans-serif; /*The monospace */font-family: Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier, monospace; 6、自定义文本选择123::selection &#123; background: #e2eae2; &#125;::-moz-selection &#123; background: #e2eae2; &#125;::-webkit-selection &#123; background: #e2eae2; &#125; 7、隐藏H1文本为Logo标志1234567h1 &#123; text-indent: -9999px; margin: 0 auto; width: 320px; height: 85px; background: transparent url(\"images/logo.png\") no-repeat scroll;&#125; 8、polaroid图像边界12345678910img.polaroid &#123; background:#000; /*Change this to a background image or remove*/ border:solid #fff; border-width:6px 6px 20px 6px; box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */ -webkit-box-shadow:1px 1px 5px #333; -moz-box-shadow:1px 1px 5px #333; height:200px; /*Set to height of your image or desired div*/ width:200px; /*Set to width of your image or desired div*/&#125; 9、锚链接伪类1234a:link &#123; color: blue; &#125;a:visited &#123; color: purple; &#125;a:hover &#123; color: red; &#125;a:active &#123; color: yellow; &#125; 10、花式CSS3 Pull-引文123456789101112131415161718192021222324252627282930313233343536373839.has-pullquote:before &#123; /* Reset metrics. */ padding: 0; border: none; /* Content */ content: attr(data-pullquote); /* Pull out to the right, modular scale based margins. */ float: right; width: 320px; margin: 12px -140px 24px 36px; /* Baseline correction */ position: relative; top: 5px; /* Typography (30px line-height equals 25% incremental leading) */ font-size: 23px; line-height: 30px;&#125; .pullquote-adelle:before &#123; font-family: \"adelle-1\", \"adelle-2\"; font-weight: 100; top: 10px !important;&#125; .pullquote-helvetica:before &#123; font-family: \"Helvetica Neue\", Arial, sans-serif; font-weight: bold; top: 7px !important;&#125; .pullquote-facit:before &#123; font-family: \"facitweb-1\", \"facitweb-2\", Helvetica, Arial, sans-serif; font-weight: bold; top: 7px !important;&#125; 11、全屏背景和CSS31234567html &#123; background: url('images/bg.jpg') no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover;&#125; 12、CSS3梯度模板123456789#colorbox &#123; background: #629721; background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721)); background-image: -webkit-linear-gradient(top, #83b842, #629721); background-image: -moz-linear-gradient(top, #83b842, #629721); background-image: -ms-linear-gradient(top, #83b842, #629721); background-image: -o-linear-gradient(top, #83b842, #629721); background-image: linear-gradient(top, #83b842, #629721);&#125; 13、@font-face模版1234567891011@font-face &#123; font-family: 'MyWebFont'; src: url('webfont.eot'); /* IE9 Compat Modes */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff') format('woff'), /* Modern Browsers */ url('webfont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */&#125; body &#123; font-family: 'MyWebFont', Arial, sans-serif;&#125; 14、字符美化12345.amp &#123; font-family: Baskerville, 'Goudy Old Style', Palatino, 'Book Antiqua', serif; font-style: italic; font-weight: normal;&#125; 15、段落首字母12345678p:first-letter&#123; display: block; margin: 5px 0 0 5px; float: left; color: #ff3366; font-size: 5.4em; font-family: Georgia, Times New Roman, serif;&#125; 16、三角形列表前缀1234567891011121314151617ul &#123; margin: 0.75em 0; padding: 0 1em; list-style: none;&#125;li:before &#123; content: \"\"; border-color: transparent #111; border-style: solid; border-width: 0.35em 0 0.35em 0.45em; display: block; height: 0; width: 0; left: -1em; top: 0.9em; position: relative;&#125; 17、CSS 固定的页脚12345678910111213#footer &#123; position: fixed; left: 0px; bottom: 0px; height: 30px; width: 100%; background: #444;&#125;/* IE 6 */* html #footer &#123; position: absolute; top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+'px');&#125; 18、PNG 图片在 IE6下的透明度12345678910111213141516.bg &#123; width:200px; height:100px; background: url(/folder/yourimage.png) no-repeat; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='/folder/yourimage.png',sizingMethod='crop');&#125;/* 1px gif method */img, .png &#123; position: relative; behavior: expression((this.runtimeStyle.behavior=\"none\")&amp;&amp;(this.pngSet?this.pngSet=true:(this.nodeName == \"IMG\" &amp;&amp; this.src.toLowerCase().indexOf('.png')&gt;-1?(this.runtimeStyle.backgroundImage = \"none\", this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.src + \"', sizingMethod='image')\", this.src = \"images/transparent.gif\"):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace('url(\"','').replace('\")',''), this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.origBg + \"', sizingMethod='crop')\", this.runtimeStyle.backgroundImage = \"none\")),this.pngSet=true));&#125; 19、跨浏览器的最小高度12345#container &#123; min-height: 550px; height: auto !important; height: 550px;&#125; 20、CSS3发光输入框1234567891011121314151617input[type=text], textarea &#123; -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd;&#125; input[type=text]:focus, textarea:focus &#123; box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1);&#125; 21、基于文件类型的链接样式1234567891011121314151617/* external links */a[href^=\"http://\"] &#123; padding-right: 13px; background: url('external.gif') no-repeat center right;&#125; /* emails */a[href^=\"mailto:\"] &#123; padding-right: 20px; background: url('email.png') no-repeat center right;&#125; /* pdfs */a[href$=\".pdf\"] &#123; padding-right: 18px; background: url('acrobat.png') no-repeat center right;&#125; 22、强制代码包装1234567pre &#123; white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap; /* Mozilla, since 1999 */ white-space: -pre-wrap; /* Opera 4-6 */ white-space: -o-pre-wrap; /* Opera 7 */ word-wrap: break-word; /* Internet Explorer 5.5+ */&#125; 23、强制可点击条目上显示手型光标123a[href], input[type=&apos;submit&apos;], input[type=&apos;image&apos;], label[for], select, button, .pointer &#123; cursor: pointer;&#125; 24、网页顶端阴影123456789101112body:before &#123; content: \"\"; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100;&#125; 25、CSS3 对话气泡123456789101112131415161718192021222324252627282930313233343536.chat-bubble &#123; background-color: #ededed; border: 2px solid #666; font-size: 35px; line-height: 1.3em; margin: 10px auto; padding: 10px; position: relative; text-align: center; width: 300px; -moz-border-radius: 20px; -webkit-border-radius: 20px; -moz-box-shadow: 0 0 5px #888; -webkit-box-shadow: 0 0 5px #888; font-family: 'Bangers', arial, serif;&#125;.chat-bubble-arrow-border &#123; border-color: #666 transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -42px; left: 30px;&#125;.chat-bubble-arrow &#123; border-color: #ededed transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -39px; left: 30px;&#125; 26、默认的 H1-H5 题头1234567891011121314151617181920212223h1,h2,h3,h4,h5&#123; color: #005a9c;&#125;h1&#123; font-size: 2.6em; line-height: 2.45em;&#125;h2&#123; font-size: 2.1em; line-height: 1.9em;&#125;h3&#123; font-size: 1.8em; line-height: 1.65em;&#125;h4&#123; font-size: 1.65em; line-height: 1.4em;&#125;h5&#123; font-size: 1.4em; line-height: 1.25em;&#125; 27、纯CSS背景噪声1234body &#123; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==); background-color: #0094d0;&#125; 28、继续列表排序123456789101112131415161718192021222324ol.chapters &#123; list-style: none; margin-left: 0;&#125; ol.chapters &gt; li:before &#123; content: counter(chapter) \". \"; counter-increment: chapter; font-weight: bold; float: left; width: 40px;&#125; ol.chapters li &#123; clear: left;&#125; ol.start &#123; counter-reset: chapter;&#125; ol.continue &#123; counter-reset: chapter 11;&#125; 29、CSS悬停工具提示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162a &#123; border-bottom:1px solid #bbb; color:#666; display:inline-block; position:relative; text-decoration:none;&#125;a:hover,a:focus &#123; color:#36c;&#125;a:active &#123; top:1px;&#125; /* Tooltip styling */a[data-tooltip]:after &#123; border-top: 8px solid #222; border-top: 8px solid hsla(0,0%,0%,.85); border-left: 8px solid transparent; border-right: 8px solid transparent; content: \"\"; display: none; height: 0; width: 0; left: 25%; position: absolute;&#125;a[data-tooltip]:before &#123; background: #222; background: hsla(0,0%,0%,.85); color: #f6f6f6; content: attr(data-tooltip); display: none; font-family: sans-serif; font-size: 14px; height: 32px; left: 0; line-height: 32px; padding: 0 15px; position: absolute; text-shadow: 0 1px 1px hsla(0,0%,0%,1); white-space: nowrap; -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125;a[data-tooltip]:hover:after &#123; display: block; top: -9px;&#125;a[data-tooltip]:hover:before &#123; display: block; top: -41px;&#125;a[data-tooltip]:active:after &#123; top: -10px;&#125;a[data-tooltip]:active:before &#123; top: -42px;&#125; 30、在一个打印页面显示URLS12345@media print &#123; a:after &#123; content: \" [\" attr(href) \"] \"; &#125; &#125; 31、禁用移动Webkit高亮12345678body &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 32、CSS3 带圆点的图案12345body &#123; background: radial-gradient(circle, white 10%, transparent 10%), radial-gradient(circle, white 10%, black 10%) 50px 50px; background-size: 100px 100px;&#125; 33、CSS3 方格图案1234567body &#123; background-color: white; background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black), linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black); background-size: 100px 100px; background-position: 0 0, 50px 50px;&#125; 34、Github Fork 缎带1234567891011121314151617181920212223242526.ribbon &#123; background-color: #a00; overflow: hidden; /* top left corner */ position: absolute; left: -3em; top: 2.5em; /* 45 deg ccw rotation */ -moz-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); /* shadow */ -moz-box-shadow: 0 0 1em #888; -webkit-box-shadow: 0 0 1em #888;&#125;.ribbon a &#123; border: 1px solid #faa; color: #fff; display: block; font: bold 81.25% 'Helvetiva Neue', Helvetica, Arial, sans-serif; margin: 0.05em 0 0.075em 0; padding: 0.5em 3.5em; text-align: center; text-decoration: none; /* shadow */ text-shadow: 0 0 0.5em #444;&#125; 35、压缩的 CSS 字体属性123p &#123; font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica;&#125; 36、页面卷曲效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ul.box &#123; position: relative; z-index: 1; /* prevent shadows falling behind containers with backgrounds */ overflow: hidden; list-style: none; margin: 0; padding: 0;&#125; ul.box li &#123; position: relative; float: left; width: 250px; height: 150px; padding: 0; border: 1px solid #efefef; margin: 0 30px 30px 0; background: #fff; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;&#125; ul.box li:before,ul.box li:after &#123; content: ''; z-index: -1; position: absolute; left: 10px; bottom: 10px; width: 70%; max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */ max-height: 100px; height: 55%; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); -ms-transform: skew(-15deg) rotate(-6deg); -o-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg);&#125; ul.box li:after &#123; left: auto; right: 10px; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); -ms-transform: skew(15deg) rotate(6deg); -o-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg);&#125; 37、发光锚链接123456789101112131415161718192021222324a &#123; color: #00e;&#125;a:visited &#123; color: #551a8b;&#125;a:hover &#123; color: #06e;&#125;a:focus &#123; outline: thin dotted;&#125;a:hover, a:active &#123; outline: 0;&#125;a, a:visited, a:active &#123; text-decoration: none; color: #fff; -webkit-transition: all .3s ease-in-out;&#125;a:hover, .glow &#123; color: #ff0; text-shadow: 0 0 10px #ff0;&#125; 38、饶有特色的 CSS3 展示横条1234567891011121314151617181920212223242526272829.featureBanner &#123; position: relative; margin: 20px&#125;.featureBanner:before &#123; content: \"Featured\"; position: absolute; top: 5px; left: -8px; padding-right: 10px; color: #232323; font-weight: bold; height: 0px; border: 15px solid #ffa200; border-right-color: transparent; line-height: 0px; box-shadow: -0px 5px 5px -5px #000; z-index: 1;&#125; .featureBanner:after &#123; content: \"\"; position: absolute; top: 35px; left: -8px; border: 4px solid #89540c; border-left-color: transparent; border-bottom-color: transparent;&#125; 转自：每位设计师都应该拥有的50个CSS代码片段 参考自： 30 Useful CSS Snippets for Developers","categories":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"}]},{"title":"sublime常用插件","slug":"sublime-plugin","date":"2014-07-31T16:00:00.000Z","updated":"2018-07-26T07:08:26.508Z","comments":true,"path":"2014/08/01/sublime-plugin/","link":"","permalink":"http://007sair.github.io/2014/08/01/sublime-plugin/","excerpt":"收集一些常用的sublime插件，具体使用方式请到 Package Control 自行查找。 常用插件SublimeCodeIntel 代码自动提示，若报错可关闭错误提示","text":"收集一些常用的sublime插件，具体使用方式请到 Package Control 自行查找。 常用插件SublimeCodeIntel 代码自动提示，若报错可关闭错误提示 jQuery jq代码自动补全，tab触发格式自行查阅此插件包的snippets文件。 SCSS scss代码颜色高亮，安装后在sublime右下角选择scss KeymapManager Ctrl+Alt+K 查看快捷键冲突 DocBlockr 自动补全注释，使用方法：/** -&gt; Tab AutoFileName 文件路径自动提示，已知会影响下拉提示（装此插件后，已自定义的函数不提示了） Alignment 等号对齐，在Preferences -&gt; package settings -&gt; Alignment -&gt; Settings User添加冒号对齐。 12345&#123; \"align_indent\": false, \"alignment_chars\": [\"=\", \":\"], \"alignment_space_chars\": [\"=\", \":\"]&#125; Clipboard History 保存复制粘贴历史记录 Press ctrl-alt-v to show the history. Press ctrl-alt-d to clear the history. Press ctrl-shift-v to paste the previous (older) history entry. Press ctrl-shift-alt-v to paste the next (newer) history entry. Placeholders 占位符 使用方法见此文件夹的snippet cssCommentsSnippets css添加注释预置 jsConsole js控制台自动提示 CSS-Format css格式化 Edit -&gt; css Format SassBeautify sass格式化 Ctrl+Shift+P -&gt; sassbeautify Autoprefixer Ctrl+Alt+Shift+P 自动增加前缀 ，依赖 nodejs 1234567//browserslist&#123; \"browsers\": [\"last 1 version\", \"&gt; 10%\", \"&gt; 5% in US\", \"ie 8\", \"ie 7\"]&#125;[ &#123; \"keys\": [\"alt+ctrl+shift+p\"], \"command\": \"autoprefixer\" &#125;] MarkdownEditing 模板工具，将Markdown.sublime-settings中的color_scheme 替换 “设置-用户”中的color_scheme JS模板插件javaScriptSnippets 自动补全js代码，下拉提示及触发格式自行查阅插件包内的snippet jQuerySnippets 自动补全jq代码，下拉提示及触发格式自行查阅插件包内的snippet insertCallback Alt+C 自动补全callback函数 使用tab依次切换编辑文本块 JS插件AdvancedNewFile Ctrl+Alt+N 快速创建文件 Http Requester Ctrl+Alt+R 使用此快捷需先选中注释的测试地址 SublimeLinter-jshint js校验 依赖：SublimeLinter NodeJS 需安装npm包，cmd命令：npm install -g jshint (jshint版本需&gt;2.4) 需创建配置文件.jshintrc,文件为json格式，具体配置见：http://jshint.com/docs/options/","categories":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/categories/tool/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://007sair.github.io/tags/sublime/"},{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/tags/tool/"}]},{"title":"javascript传值和传址","slug":"js-zhi","date":"2014-05-21T16:00:00.000Z","updated":"2018-07-26T07:08:26.508Z","comments":true,"path":"2014/05/22/js-zhi/","link":"","permalink":"http://007sair.github.io/2014/05/22/js-zhi/","excerpt":"定义关于传值和传址，权威指南有这么一些话： 在js中和在所有编程语言中一样，可以有三种重要的方式来操作一个数据值： 首先，可以复制它。例如：把它赋给一个新的变量； 其次，可以把它作为参数传递给一个函数或方法。 再次，可以把它和另外一个值进行比较看两个值是否相等。","text":"定义关于传值和传址，权威指南有这么一些话： 在js中和在所有编程语言中一样，可以有三种重要的方式来操作一个数据值： 首先，可以复制它。例如：把它赋给一个新的变量； 其次，可以把它作为参数传递给一个函数或方法。 再次，可以把它和另外一个值进行比较看两个值是否相等。 传值：当一个数据是通过值被操作，那么所关系到的是数据的值。在赋值过程中，对实际的值制作了一份拷贝，这份拷贝存储到一个变量、对象属性或数组中。拷贝的值和原始的值是分别存储的两份完全独立的值。当一份数据通过值传递给一个函数，数据的一份拷贝被传递给了这个函数；如果函数修改了这个值，修改只会影响到函数所拥有的该数据的拷贝，而不会影响到原始数据。最后，当一个数据通过值和另一个数据作比较，两份继而不同的数据片段必须确实代表相同的值（意味着要进行逐个字节比较后发现是否相同）。 传址：使用这种方式，数据值有一份真实的拷贝，被操作的是对该值的引用（地址）。如果以传址方式操作一个值，变量并不会直接存储该值，它们只是存储该值的地址，被复制、传递和比较的都是这个地址。因此，在传址的赋值操作中，只是这个值的地址被赋值，而不是这个值的一份拷贝，更不是值本身。在赋值后，新的变量所指向的值和原始变量所指向的值相同，两个地址都有效，都可以用来操作这个值。如果值通过一个地址发生了变化，这个改变也会影响原始变量。 表格： 传值 传址 复制 实际复制的是值，存在两个不同的、独立的拷贝 复制的值是对数值的引用。如果通过这个新的引用修改了数值，这个改变对最初的引用来说也可见。 传递 传递给函数的是值的一个独立拷贝，对它的改变在函数外部没有影响 传递给函数的是对数值的一个引用。如果函数通过传递给它的引用修改了数值，这个改变在函数外部也可见。 比较 比较的是两个独立的值（通常逐字节比较），以判断它们是否相等 比较的是两个引用，以判断它们引用的是否是同一个数值。对两个不同的数值的引用不相等，即使这两个数值是由相同的字节构成的 js基本规则：基本数据类型（数字、布尔）通过传值来操作；引用类型（对象、数组和函数）通过传址操作。字符串通常被当作基本类型，因为它们不是对象。 12Function instanceof Object //trueArray instanceof Object //true 举例看下面的demo： 1234new Object == new Object //false[] == [] //false[1,2] == [1,2] //falsenull == null //true [] 和 [] 两个值看似一样，为什么不相等，这个设计到js的传值和传址。 用以下代码演示传值和传址的区别： 1234567891011121314151617181920//传值var m = 10;var n = m;n = 2;console.log(m); //10console.log(n); //2console.log(m == n); //false//传址var o1 = &#123;&#125;;var o2 = o1;o1.x = 5;var o3 = &#123;&#125;;var o4 = &#123;&#125;;console.log(o1 == o2); //true o1的引用地址赋值给o2，所以有相同地址，即相等console.log(o3 == o4); //false 看起来是空对象,其实是两个不相同的引用地址，即不相等console.log(o1.x); //5console.log(o2.x); //5 javascript类型总览图","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"sublime常用快捷键","slug":"sublime-cad","date":"2014-04-30T16:00:00.000Z","updated":"2018-07-26T07:08:26.507Z","comments":true,"path":"2014/05/01/sublime-cad/","link":"","permalink":"http://007sair.github.io/2014/05/01/sublime-cad/","excerpt":"常用快捷键 ctrl+p 查找当前项目中的文件和快速搜索，功能如下： 切换文档（goToAnything：需先添加项目至左侧sidebar），不单单是在当前打开的文档中切换，包括整个project，并可用关键字过滤； 关键字@开头，匹配的是文档中的函数及其他关键内容（如：HTML匹配的元素id，CSS匹配的选择器）； 关键字#开头，全文搜索； 关键字：开头，后跟数字可跳转至相应的行，快捷键为ctrl+g","text":"常用快捷键 ctrl+p 查找当前项目中的文件和快速搜索，功能如下： 切换文档（goToAnything：需先添加项目至左侧sidebar），不单单是在当前打开的文档中切换，包括整个project，并可用关键字过滤； 关键字@开头，匹配的是文档中的函数及其他关键内容（如：HTML匹配的元素id，CSS匹配的选择器）； 关键字#开头，全文搜索； 关键字：开头，后跟数字可跳转至相应的行，快捷键为ctrl+g ctrl+l 选择整行(按住-继续选择下行) ctrl+g 跳转到相应的行 ctrl+j 合并行(已选择需要合并的多行时) ctrl+m 光标移动至括号内开始或结束的位置 ctrl+/ 注释整行(如已选择内容，同“ctrl+shift+/”效果) ctrl+z 撤销 ctrl+y 恢复撤销 ctrl+t 词互换（先选中要互换的两对词） ctrl+d 删除当前行 ctrl+n 新建文件 ctrl+s 保存文件 ctrl+k/b 显示隐藏左侧边栏 ctrl+x 剪切整行 ctrl+kk 从光标处删除至行尾 ctrl+ku 改为大写 ctrl+kl 改为小写 ctrl+kt 折叠属性 ctrl+k0 展开所有(k+零) ctrl+enter 插入行后 ctrl+shift+enter 插入行前 ctrl+k+backspace 从光标处删除至行首 ctrl+kk 从光标处删除至行尾 ctrl+shift+a 选择光标位置父标签对儿 ctrl+shift+d 复制光标所在整行，插入在该行之前 ctrl+shift+f 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找 ctrl+shift+m 选择括号内的内容(按住-继续选择父括号) ctrl+shift+↑ 与上行互换 ctrl+shift+↓ 与下行互换 ctrl+shift+s 另存为 ctrl+shift+[ 折叠代码（在html中配合ctrl+shift+t有奇效） ctrl+shift+] 不折叠 ctrl+shift+t * 鼠标在HTML内时，选中当前层级的所有元素 * 鼠标在其他文件中时，重新打开最近关闭文件 ctrl+鼠标左键 可以同时选择要编辑的多处文本 shift+鼠标右键 可以用鼠标进行竖向多行选择，功能同鼠标中建 ctrl+F2 设置/取消书签 shift+F2 上一个书签 F2 下一个书签 F11 全屏状态 shift+F11 免打扰模式 alt+. 闭合当前标签 alt+shift+1 （非小键盘）窗口分屏，恢复默认1屏 alt+shift+2 左右分屏-2列 alt+shift+3 左右分屏-3列 alt+shift+4 左右分屏-4列 alt+shift+5 等分4屏 alt+shift+8 垂直分屏-2屏 alt+shift+9 垂直分屏-3屏 alt+F3 选中文本按下此快捷键，即可一次性选择全部的相同文本进行同时编辑 插件：sublime Tmpl * ctrl+alt+h 创建html文件 * ctrl+alt+j 创建js文件 * ctrl+alt+c 创建css文件 * ctrl+alt+p 创建php文件 * ctrl+alt+shift+p 创建pythone文件 * ctrl+alt+r 创建ruby文件 插件：Markdown * alt+m 在浏览器上查看当前md文档 * ctrl+b 为该md文档创建html页面","categories":[{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/categories/tool/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://007sair.github.io/tags/sublime/"},{"name":"tool","slug":"tool","permalink":"http://007sair.github.io/tags/tool/"}]},{"title":"7个javascript的基础点","slug":"js-basic","date":"2014-03-17T16:00:00.000Z","updated":"2018-07-26T07:08:26.507Z","comments":true,"path":"2014/03/18/js-basic/","link":"","permalink":"http://007sair.github.io/2014/03/18/js-basic/","excerpt":"1. 在 String.prototype.replace 方法中使用 /g 和 /i 标志位令很多 JavaScript 初学者意外的是，字符串的 replace 方法并不会 替换所有匹配的子串——而仅仅替换第一次匹配。当然 JavaScript 老手们都知道这里可以使用正则表达式，并且需要加上一个全局标志位（/g）：","text":"1. 在 String.prototype.replace 方法中使用 /g 和 /i 标志位令很多 JavaScript 初学者意外的是，字符串的 replace 方法并不会 替换所有匹配的子串——而仅仅替换第一次匹配。当然 JavaScript 老手们都知道这里可以使用正则表达式，并且需要加上一个全局标志位（/g）： 1234567// Mistake // 踩到坑了 var str = \"David is an Arsenal fan, which means David is great\"; str.replace(\"David\", \"Darren\"); // \"Darren is an Arsenal fan, which means David is great\" // Desired // 符合预期 str.replace(/David/g, \"Darren\"); // \"Darren is an Arsenal fan, which means Darren is great\" 另一个基本的逻辑错误就是在大小写不敏感的校验场合（字母可大写可小写）没有忽略大小写，此时 /i 标志位就很实用： 1str.replace(/david/gi, \"Darren\"); // \"Darren will always be an Arsenal fan, which means Darren will always be great\" （译注：上面这段例程我没有看懂用意，可能是注释有误吧……）每个 JavaScript 开发者都曾踩过这两个标志位的坑——因此别忘了在适当的时候用上它们！ 2. 类数组对象和 Array.prototype.slice 方法数组的 slice 方法通常用来从一个数组中抽取片断。但很多开发者不了解的是，这个方法还可以用来将“类数组”元素（比如 arguments 参数列表、节点列表和属性列表）转换成真正的数组：（译注：DOM 元素的属性列表通过 attributes 属性获取，比如 document.body.attributes。） 1234567var nodesArr = Array.prototype.slice.call(document.querySelectorAll(\"div\"));// \"true\" array of DIVs// 得到一个由 div 元素组成的“真正的”数组var argsArr = Array.prototype.slice.call(arguments);// changes arguments to \"true\" array// 把 arguments 转换成一个“真正的”数组 你还可以使用一次简单的 slice 调用来克隆一个数组：var clone = myArray.slice(0); // naive clone // 浅克隆 （译注：这里的参数 0 也可以省略，我估计 undefined 被 slice 方法自动转换为 0 了吧。）Array.prototype.slice 绝对是 JavaScript 世界中的一玫珍宝，但 JavaScript 初学者们显然还没有意识到它的全部潜力。 3. Array.prototype.sort 方法数组的 sort 方法 远远没有被充分利用，而且可能比开发者们想像的更加强大。很多开发者可能觉得 sort 方法可以用来做这种事情： 12[1, 3, 9, 2].sort();// 返回 [1, 2, 3, 9] ……这没错，但它还有更强大的用法，比如这样： 123456789101112131415[ &#123; name: \"Robin Van PurseStrings\", age: 30 &#125;, &#123; name: \"Theo Walcott\", age: 24 &#125;, &#123; name: \"Bacary Sagna\", age: 28 &#125; ].sort(function(obj1, obj2) &#123; // Ascending: first age less than the previous // 实现增序排列：前者的 age 小于后者 return obj1.age - obj2.age; &#125;); // Returns: // [ // &#123; name: \"Theo Walcott\", age: 24 &#125;, // &#123; name: \"Bacary Sagna\", age: 28 &#125;, // &#123; name: \"Robin Van PurseStrings\", age: 30 &#125; // ] 你不仅可以对简单类型的数组项进行排序，可以通过属性来排序对象。如果哪天服务器端发来一段 JSON 数据，而且其中的对象需要排序，你可别忘了这一招！ 4. 用 length 属性来截断数组几乎所有开发者都踩过 JavaScript 的这个坑——“传对象只是传引用”。开发者们经常会试图 把一个数组清空，但实际上却错误地创建了一个新数组。 123456789var myArray = yourArray = [1, 2, 3]; // :( // 囧 myArray = []; // `yourArray` is still [1, 2, 3] // `yourArray` 仍然是 [1, 2, 3] // The right way, keeping reference // 正确的方法是保持引用 myArray.length = 0; // `yourArray` and `myArray` both [ ] // `yourArray` 和 `myArray`（以及其它所有对这个数组的引用）都变成 [ ] 了 坑里的人们终于明白，原来传对象只是在传引用。因此当我把 myArray 重新赋值为 [] 时，确实会创建出一个新的空数组，但其它对老数组的引用仍然没变！大坑啊！还是换用截断的方法吧，少年。 5. 使用 push 来合并数组在上面的第 2 节里，我展示了数组的 slice 和 apply 方法所能组合出的几个小妙招，所以对于数组方法的其它技巧，你应该已经做好心理准备了吧。这次我们使用 push 方法来合并数组： 1234var mergeTo = [4,5,6]; var mergeFrom = [7,8,9]; Array.prototype.push.apply(mergeTo, mergeFrom); mergeTo; // is: [4, 5, 6, 7, 8, 9] 这是一项不为人知的小技巧，简单的原生方法就可以实现数组合并这样的常见任务。（译注：这个方法的巧妙之外不仅在于 push 方法可以接收多个参数，还涉及到 apply 方法的第二个参数的用法。） 6. 高效探测功能特性和对象属性很多时候开发者们会像下面这样来探测浏览器的某个特性： 1234if(navigator.geolocation) &#123; // Do some stuff // 在这里干点事情 &#125; 当然这可以正常工作，但它并不一定有很好的效率。因为这个对象探测方法会在浏览器中初始化资源。在过去，上面的代码片断可能会在某些浏览器下导致内存泄露。更好、更快的方法是检查对象是否包含某个键名： 1234if(\"geolocation\" in navigator) &#123; // Do some stuff // 在这里干点事情 &#125; 键名检查十分简单，而且可以避免内存泄露。另外请注意，如果这个属性的值是假值，那么前一种探测方式将会得到“否”的结果，并不能真正探测出这个键名是否存在。 7. 事件对象的 preventDefault 和 stopPropagation 方法很多时候，当一个动作元素（比如链接）被点击时，会触发某个功能。显然我们并不希望点击链接时浏览器顺着这个链接跳转，于是我们会习惯性地使用 JavaScript 类库的 Event.stop 方法： 12345$(\"a.trigger\").on(\"click\", function(e) &#123; e.stop(); // Do more stuff // 在这里干点事情 &#125;); （译注：不知道哪个类库有这个方法，估计其作用相当于 return false; 吧。语法看起来像 jQuery，但 jQuery 并没有这个方法，而且 jQuery 是支持 e.preventDefault 和 e.stopPropagation 方法的。） 这个懒方法有一个问题，它不仅阻止了浏览器的默认动作，同时也阻止了事件继续冒泡。这意味着元素上绑定的其它事件监听器将不会被触发，因为它们根本就不知道有事件发生。此时不妨使用 preventDefault 吧！ JavaScript 老鸟们看到这篇文章可能会说“我早知道了”，但说不定什么时候，他们就会在某一点上栽跟头。提醒大家留意 JavaScript 中的各种小细节，失之毫厘谬以千里啊！","categories":[{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/categories/javascript/"}],"tags":[{"name":"study","slug":"study","permalink":"http://007sair.github.io/tags/study/"},{"name":"javascript","slug":"javascript","permalink":"http://007sair.github.io/tags/javascript/"}]},{"title":"css常见bug","slug":"css-bug","date":"2013-07-20T16:00:00.000Z","updated":"2018-07-26T07:08:26.507Z","comments":true,"path":"2013/07/21/css-bug/","link":"","permalink":"http://007sair.github.io/2013/07/21/css-bug/","excerpt":"IE6如何定义高度很小的容器1div&#123; overflow: hidden; height: 1px; font-size: 0; line-height: 0;&#125; IE6下min-height兼容问题?1div&#123; min-height: 200px; height: auto !important; _height: 200px;&#125; /*顺序不可变*/","text":"IE6如何定义高度很小的容器1div&#123; overflow: hidden; height: 1px; font-size: 0; line-height: 0;&#125; IE6下min-height兼容问题?1div&#123; min-height: 200px; height: auto !important; _height: 200px;&#125; /*顺序不可变*/ IE6使用滤镜PNG图片透明后，容器内链接失效的问题12div&#123; width: 300px; height: 100px; _filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='*.png');&#125;a&#123; _position: relative;&#125; /*为容器内的链接定义相对定位属性position的值为relative*/ IE6/7使用绝对定位左右布局，左侧元素位置偏移描述：左侧定位元素在不加left:0的情况下，右侧元素自适应时，左侧元素在IE6下会发生偏移 解决办法： 右侧元素使用padding-left；不要使用margin-left; 给左侧元素加left:0 IE6/7下设置滚动条(overflow:auto)不起作用：解决办法：加一个positon:relative IE6/7下用position:absolute后无法显示的原因position:absolute定位元素在IE6下无法显示，奇怪的是平时用position:absolute进行定位却没有这个问题。 原来IE6下采用绝对定位的元素如果紧接着浮动元素，那么就有可能显示不出来。 问题找到了，解决办法也就找到，主要思路就两种： 采用position:aboslute进行绝对定位的元素不要紧接着浮动元素。 在采用position:aboslute进行绝对定位的元素前增加一个清除浮动的元素。 IE6/7下textarea右侧竖滚动条痕迹消失的问题1textarea&#123;overflow: auto;&#125; IE6/7图片下方出现几像素的空白间隙？ 使li浮动，并设置img为块级元素 img{vertical-align: bottom/middle/top;} 其中的任何一个都可以 IE6/7下当li中出现2个或以上的浮动时，li之间产生的空白间隙bug方法： 1li&#123;vertical-align:top;&#125; /*除了top值，还可以设置为text-top | middle | bottom | text-bottom，甚至特定的&lt;length&gt;和&lt;percentage&gt;值都可以*/ IE6下line-height失效bug原因: 当在一个容器里文字和img、input、textarea、select、object等元素相连的时候，对这个容器设置的line-height数值会失效； 同时以上元素的行高可能×2： 解决方法： 1.div li input&#123;margin:10px 0px;vertical-align:middle;&#125; /*margin的作用在于调整他和容器上下的间距*/ 受影响的浏览器： IE 5.01 / IE 5.5 / IE 6;解决方法： 对和文字相连接的img、input、textarea、select、object等元素加以属性 margin: (所属line-height-自身img,input,select,object高度)/2px 0;vertical-align:middle; 12.hh li&#123; line-height:50px; &#125;.hh li img&#123;margin:20px 0;vertical-align:middle; &#125; /*所属line-height-自身img,input,select,object高度)/2px */ IE6/7/8下input、button的padding兼容问题解决办法： 123input,button&#123;overflow:visible;&#125;/*or*/input&#123; padding: 0 .25em; width: auto; _width: 0; overflow:visible !ie;&#125; 摘自：http://www.planabc.net/2008/11/12/the_stretched_buttons_bug/ 这个对于FF和IE下对input按钮设置padding大小不一，可以很好的解决 火狐：input::-moz-focus-inner {border: 0; padding: 0; margin-top: -1px; margin-bottom: -2px;} a标签使用绝对定位后无法点击设置一张背景图后，需要此背景图可点击，于是在背景图的上层绝对定位一个有宽高的a标签，但a标签无法被点击！ 解决办法为：给a标签增加 background:url(about:blank) 或 background-color:white;opacity:0;filter:alpha(opacity=0) 解决Firefox下input button内文字垂直居中众所周知，在Firefox下input type=”button”的文字是不好居中的，原因在于Firefox自己比较二，弄了个私有属性，导致以下问题的出现： 按钮左右本身有2px的间距（FF私有属性写了padding:0 2px所致）； 按钮文字居中是不行的（此时设置padding-bottom是没用的） ； 等等… 解决办法： 123456input[type=\"reset\"]::-moz-focus-inner,input[type=\"button\"]::-moz-focus-inner,input[type=\"submit\"]::-moz-focus-inner,input[type=\"file\"] &gt; input[type=\"button\"]::-moz-focus-inner&#123; border:none;padding:0;&#125; ie中如何让超出宽度的文字显示为省略号？定义容器为： 1overflow:hidden; width:100px; white-space:nowrap; text-overflow:ellipsis; 如何在点文字时也选中checkbox?方法1： 12&lt;!-- 该方式所有主流浏览器都支持 --&gt;&lt;input type=\"checkbox\" id=\"chk1\" name=\"chk\" /&gt;&lt;label for=\"chk1\"&gt;选项一&lt;/label&gt; 方法2： 12&lt;!-- 该方式相比方法1更简洁，但IE6及更早浏览器不支持 --&gt;&lt;label&gt;&lt;input type=\"checkbox\" name=\"chk\" /&gt;选项一&lt;/label&gt; 为什么在web标准下ie无法设置滚动条的颜色？将设置滚动条颜色的样式定义到html标签选择符上即可解决办法：在CSS中对body的设置改为对html的 1body &#123; scrollbar-face-color:#f6f6f6; scrollbar-highlight-color:#fff; scrollbar-shadow-color:#eeeeee; scrollbar-3dlight-color:#eeeeee; scrollbar-arrow-color:#000; scrollbar-track-color:#fff; scrollbar-darkshadow-color:#fff;&#125; 解决办法是将body换成html 超链接访问过后hover样式就不出现的问题被点击访问过的超链接样式不在具有hover和active了,很多人应该都遇到过这个问题,解决方法是改变CSS属性的排列顺序: L-V-H-A Code FORM标签样式问题这个标签在IE中,将会自动margin一些边距,而在FF中margin则是0,因此,如果想显示一致,所以最好在css中指定margin和 padding,针对上面两个问题,我的css中一般首先都使用这样的样式ul,form{margin:0;padding:0;}给定义死了,所以后面就不会为这个头疼了.","categories":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://007sair.github.io/tags/css/"},{"name":"坑","slug":"坑","permalink":"http://007sair.github.io/tags/坑/"}]},{"title":"中文网页重设与排版：TYPO.CSS","slug":"TYPO","date":"2012-12-21T16:00:00.000Z","updated":"2018-07-26T07:08:26.505Z","comments":true,"path":"2012/12/22/TYPO/","link":"","permalink":"http://007sair.github.io/2012/12/22/TYPO/","excerpt":"","text":"关于Typo.css排版实例例1：论语学而篇第一例2：英文排版附录Typo.css 排版偏重点开源许可一、关于Typo.cssTypo.css 的目的是，在一致化浏览器排版效果的同时，构建最适合中文阅读的网页排版。现状和如何去做：排版是一个麻烦的问题# 附录一，需要精心设计，而这个设计却是常被视觉设计师所忽略的。前端工程师更常看到这样的问题，但不便变更。因为在多个 OS 中的不同浏览器渲染不同，改动需要多的时间做回归测试，所以改变变得更困难。而像我们一般使用的 Yahoo、Eric Meyer 和 Alice base.css 中采用的 Reset 都没有很好地考虑中文排版。Typo.css 要做的就是解决中文排版的问题。Typo.css 测试于如下平台：OS/浏览器FirefoxChromeSafariOperaIE9IE8IE7IE6OS X✔✔✔✔----Win 7✔✔✔✔✔✔✔-Win XP✔✔✔✔-✔✔✔Ubuntu✔✔-✔----中文排版的重点和难点在中文排版中，HTML4 的很多标准在语义在都有照顾到。但从视觉效果上，却很难利用单独的 CSS 来实现，像着重号（例：这里强调一下）。在 HTML4 中，专名号标签（&lt;u&gt;）已经被放弃，而 HTML5 被重新提起。Typo.css 也根据实际情况提供相应的方案。我们重要要注意的两点是：语义：语义对应的用法和样式是否与中文排版一致表现：在各浏览器中的字体、大小和缩放是否如排版预期对于这些，Typo.css 排版项目的中文偏重注意点，都添加在附录中，详见：附录一：Typo.css 排版偏重点目前已有像百姓网等全面使用Typo.css 的项目，测试平台的覆盖，特别是在移动端上还没有覆盖完主流平台，希望有能力的同学能加入测试行列，或者加入到Typo.css 的开发。加入方法：参与Typo.css 开发。如有批评、建议和意见，也随时欢迎给在 Github 直接提issues，或给我发邮件。二、排版实例：提供2个排版实例，第一个中文实例来自于来自于张燕婴的《论语》，由于古文排版涉及到的元素比较多，所以采用《论语》中《学而》的第一篇作为排版实例介绍；第2个来自到经典的 Lorem Ipsum，并加入了一些代码和列表等比较具有代表性的排版元素。例1：论语学而篇第一作者：孔子（前551年9月28日－前479年4月11日 ）本篇引语 《学而》是《论语》第一篇的篇名。《论语》中各篇一般都是以第一章的前二三个字作为该篇的篇名。《学而》一篇包括16章，内容涉及诸多方面。其中重点是「吾日三省吾身」；「节用而爱人，使民以时」；「礼之用，和为贵」以及仁、孝、信等道德范畴。原文子曰：「学而时习之，不亦说乎？有朋自远方来，不亦乐乎？人不知，而不愠，不亦君子乎？」译文孔子说：「学了又时常温习和练习，不是很愉快吗？有志同道合的人从远方来，不是很令人高兴的吗？人家不了解我，我也不怨恨、恼怒，不也是一个有德的君子吗？」评析宋代著名学者朱熹对此章评价极高，说它是「入道之门，积德之基」。本章这三句话是人们非常熟悉的。历来的解释都是：学了以后，又时常温习和练习，不也高兴吗等等。三句话，一句一个意思，前后句子也没有什么连贯性。但也有人认为这样解释不符合原义，指出这里的「学」不是指学习，而是指学说或主张；「时」不能解为时常，而是时代或社会的意思，「习」不是温习，而是使用，引申为采用。而且，这三句话不是孤立的，而是前后相互连贯的。这三句的意思是：自己的学说，要是被社会采用了，那就太高兴了；退一步说，要是没有被社会所采用，可是很多朋友赞同我的学说，纷纷到我这里来讨论问题，我也感到快乐；再退一步说，即使社会不采用，人们也不理解我，我也不怨恨，这样做，不也就是君子吗？（见《齐鲁学刊》1986年第6期文）这种解释可以自圆其说，而且也有一定的道理，供读者在理解本章内容时参考。此外，在对「人不知，而不愠」一句的解释中，也有人认为，「人不知」的后面没有宾语，人家不知道什么呢？当时因为孔子有说话的特定环境，他不需要说出知道什么，别人就可以理解了，却给后人留下一个谜。有人说，这一句是接上一句说的，从远方来的朋友向我求教，我告诉他，他还不懂，我却不怨恨。这样，「人不知」就是「人家不知道我所讲述的」了。这样的解释似乎有些牵强。总之，本章提出以学习为乐事，做到人不知而不愠，反映出孔子学而不厌、诲人不倦、注重修养、严格要求自己的主张。这些思想主张在《论语》书中多处可见，有助于对第一章内容的深入了解。例2：英文排版Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry’s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.The standard Lorem Ipsum passage, used since the 1500s“Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.”Section 1.10.32 of “de Finibus Bonorum et Malorum”, written by Cicero in 45 BC“Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?”List style in actionIf you wish to succeed, you should use persistence as your good friend, experience as your reference, prudence as your brother and hope as your sentry.如果你希望成功，当以恒心为良友，以经验为参谋，以谨慎为兄弟，以希望为哨兵。Sometimes one pays most for the things one gets for nothing.有时候一个人为不花钱得到的东西付出的代价最高。Only those who have the patience to do simple things perfectly ever acquire the skill to do difficult things easily.只有有耐心圆满完成简单工作的人，才能够轻而易举的完成困难的事。You may want to create a perfect&lt;hr /&gt; line, despite the fact that there will never have oneLa Racheforcauld said:“Few things are impossible in themselves; and it is often for want of will, rather than of means, that man fails to succeed”. You just need to follow the browser’s behavior, and set a rightmargin to it。it will works nice as the demo you’re watching now. The following code is the best way to render typo in Chinese:h1,h2,h3,h4,h5,h6 { line-height:1;font-family:Arial,sans-serif;margin:1.4em 0 0.8em;}h1{font-size:1.8em;}h2{font-size:1.6em;}h3{font-size:1.4em;}h4{font-size:1.2em;}h5,h6{font-size:1em;}.typo p, .typo pre, .typo ul, .typo ol, .typo dl, .typo form, .typo hr { margin:1em 0 0.6em;}三、附录1、Typo.css 排版偏重点类型语义标签注意点基础标签标题h1 ～h6全局不强制大小，.typo 中标题与其对应的内容应紧贴，并且有相应的大小设置上、下标sup/sub保持与 MicroSoft Office Word 等程序的日常排版一致引用blockquote显示/嵌套样式缩写abbr是否都有下划线，鼠标hover 是否为帮助手势分割线hr显示的padding 和margin正确列表ul/ol/dl在全局没有list-style，在 .typo 中对齐正确定义列表dl全局padding 和margin为0， .typo 中对齐正确选项input[type=radio[, checkbox]]与其他form 元素排版时是否居中斜体i只设置一种斜体，让em 和cite 显示为正体强调em在全局显示正体，在.typo 中显示与b 和strong 的样式一致，为粗体加强strong/b显示为粗体标记mark类似荧光笔印刷small保持为正确字体的 80% 大小，颜色设置为浅灰色表格table全局不显示线条，在table 中显示表格外框，并且表头有浅灰背景代码pre/code字体使用courier 系字体，保持与serif 有比较一致的显示效果特殊符号着重号在文字下加点在支持:after 和:before 的浏览器可以做渐进增强实现专名号林建锋专名号，有下划线，使用u 或都.typo-u 类破折号——保持一划，而非两划人民币&yen;使用两平等线的符号，或者 HTML 实体符号&amp;yen;删除符已删除（deleted）一致化各浏览器显示，中英混排正确加强类专名号.typo-u由于u 被 HTML4 放弃，在向后兼容上推荐使用.typo-u着重符.typo-em利用:after 和:before 实现着重符清除浮动.clearfix与一般 CSS Reset 保持一对致 API注意点（1）中英文混排行高/行距（2）上下标在 IE 中显示效果（3）块/段落分割空白是否符合设计原则（4）input 多余空间问题（5）默认字体色彩，目前采用#333 在各种浏览显示比较好2、开源许可Typo.css 基于MIT License 开源，使用代码只需说明来源，或者引用license.txt 即可。","categories":[{"name":"web","slug":"web","permalink":"http://007sair.github.io/categories/web/"}],"tags":[{"name":"typoCss","slug":"typoCss","permalink":"http://007sair.github.io/tags/typoCss/"}]},{"title":"markdown基本语法","slug":"markdown","date":"2012-12-21T16:00:00.000Z","updated":"2018-07-26T07:08:26.506Z","comments":true,"path":"2012/12/22/markdown/","link":"","permalink":"http://007sair.github.io/2012/12/22/markdown/","excerpt":"标题设置在Markdown当中设置标题，有两种方式： 第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。称为类 Setext 语法： 1234567//一级标题h1 - h6===========//二级标题h1 - h6-----------","text":"标题设置在Markdown当中设置标题，有两种方式： 第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。称为类 Setext 语法： 1234567//一级标题h1 - h6===========//二级标题h1 - h6----------- 第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）,称为类 atx 语法： 12345# 这是 H1## 这是 H2###### 这是 H6 块注释（blockquote）Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。 内联方式： This is an [example link](http://example.com/). 引用方式： I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 图片（Images）图片的处理方式和链接的处理方式，非常的类似。 内联方式： ![alt text](/path/to/img.jpg &quot;Title&quot;) 引用方式： ![alt text][id] [id]: /path/to/img.jpg &quot;Title&quot; 代码（HTML中所谓的Code）实现方式有两种： 第一种：简单文字出现一个代码框。使用 &lt;blockquote&gt; 。（[`]不是单引号而是左上角的ESC下面~中的） 第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下： hello[^hello] [^hello]: hi 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题） 参考自： markdown语法说明：http://www.appinn.com/markdown/ Markdown官方网站：http://daringfireball.net/projects/markdown/ 推荐一款在线的Markdown编辑器：https://stackedit.io/","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://007sair.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://007sair.github.io/tags/Markdown/"}]}]}